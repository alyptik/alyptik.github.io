
<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="https://alyp.tk/theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="https://alyp.tk/theme/pygments/monokai.min.css">
  <link rel="stylesheet" type="text/css" href="https://alyp.tk/theme/font-awesome/css/font-awesome.min.css">

    <link href="https://alyp.tk/static/custom.css" rel="stylesheet">

    <link href="https://alyp.tk/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Joey Pabalinas — caveat lector. Atom">


    <link rel="shortcut icon" href="https://alyp.tk/images/favicon.ico" type="image/x-icon">
    <link rel="icon" href="https://alyp.tk/images/favicon.ico" type="image/x-icon">

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index, follow" />

    <!-- Chrome, Firefox OS and Opera -->
    <meta name="theme-color" content="#333">
    <!-- Windows Phone -->
    <meta name="msapplication-navbutton-color" content="#333">
    <!-- iOS Safari -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Microsoft EDGE -->
    <meta name="msapplication-TileColor" content="#333">

<meta name="author" content="Joey Pabalinas" />
<meta name="description" content="I love C. Quite simply, I find it an incredibly fun language to program in. Even through all the weird, little Heisenbugs, the segmentation faults, the incredibly confusing linker errors, it is still my favorite programming language by far. You will hear a lot of bad press about C: “There …" />
<meta name="keywords" content="">

<meta property="og:site_name" content="Joey Pabalinas — caveat lector."/>
<meta property="og:title" content="the magic of dispatch tables and dynamic arrays"/>
<meta property="og:description" content="I love C. Quite simply, I find it an incredibly fun language to program in. Even through all the weird, little Heisenbugs, the segmentation faults, the incredibly confusing linker errors, it is still my favorite programming language by far. You will hear a lot of bad press about C: “There …"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="https://alyp.tk/the-magic-of-dispatch-tables-and-dynamic-arrays.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2017-11-29 21:16:00-10:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="https://alyp.tk/author/joey-pabalinas.html">
<meta property="article:section" content="code"/>
<meta property="og:image" content="https://alyp.tk/images/profile.png">

  <title>Joey Pabalinas — caveat lector. &ndash; the magic of dispatch tables and dynamic arrays</title>

</head>
<body>
  <aside>
    <div>
      <a href="https://alyp.tk">
        <img src="https://alyp.tk/images/profile.png" alt="Joey Pabalinas — caveat lector." title="Joey Pabalinas — caveat lector.">
      </a>
      <h1><a href="https://alyp.tk">Joey Pabalinas — caveat lector.</a></h1>

<p>hello, i'm joey and i drink, smoke, and smile too much.</p>
      <nav>
        <ul class="list">

          <li><a href="https://theprose.com/alyptik" target="_blank">my prose</a></li>
        </ul>
      </nav>

      <ul class="social">
        <li><a class="sc-github-alt" href="https://github.com/alyptik" target="_blank"><i class="fa fa-github-alt"></i></a></li>
        <li><a class="sc-soundcloud" href="https://soundcloud.com/metafornication" target="_blank"><i class="fa fa-soundcloud"></i></a></li>
        <li><a class="sc-twitter" href="https://twitter.com/alyptik" target="_blank"><i class="fa fa-twitter"></i></a></li>
        <li><a class="sc-youtube" href="https://www.youtube.com/channel/UCgFwbRRqu_rOyt0Sn3OORPw" target="_blank"><i class="fa fa-youtube"></i></a></li>
        <li><a class="sc-facebook" href="https://facebook.com/alyptik" target="_blank"><i class="fa fa-facebook"></i></a></li>
        <li><a class="sc-google" href="https://google.com/+JoeyPabalinas" target="_blank"><i class="fa fa-google"></i></a></li>
        <li><a class="sc-stack-overflow" href="https://stackoverflow.com/users/7364491/joey-pabalinas?tab=profile" target="_blank"><i class="fa fa-stack-overflow"></i></a></li>
        <li><a class="sc-rss" href="https://alyp.tk/feeds/all.atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li>
      </ul>
    </div>


  </aside>
  <main>

    <nav>
      <a href="https://alyp.tk">    Home
</a>

      <a href="/archives.html">Archives</a>
      <a href="/categories.html">Categories</a>
      <a href="/tags.html">Tags</a>

      <a href="https://alyp.tk/feeds/all.atom.xml">    Atom
</a>

    </nav>

<article class="single">
  <header>
      
    <h1 id="the-magic-of-dispatch-tables-and-dynamic-arrays">the magic of dispatch tables and dynamic arrays</h1>
    <p>
          Posted on Wed 29 November 2017 in <a href="https://alyp.tk/category/code.html">code</a>


    </p>
  </header>


  <div>
    <p>I <em>love</em> C. Quite simply, I find it an incredibly fun language to program in. Even through all the weird, little Heisenbugs, the segmentation faults, the incredibly confusing linker errors, it is still my favorite programming language by far. You will hear a lot of bad press about C:</p>
<blockquote>
<p>“There is no memory safety!”  </p>
</blockquote>
<p>or  </p>
<blockquote>
<p>“The typing system is dated and unreliable!”  </p>
</blockquote>
<p>maybe even  </p>
<blockquote>
<p>“The language makes it far too easy to shoot yourself in the foot!”  </p>
</blockquote>
<p>And granted, these criticisms are not without merit. C is a old language; the origins of C take place around 1971, when <em>Dennis M. Ritchie</em> of <em>Bell Labs</em> rewrote B as a language named NB, which he eventually refined into C. However, in my opinion the greatest sins commonly committed by C programmers is the tendency to snob the features and inventions of other languages, dismissing potentially useful constructs with an attitude of it being the “easy way out,” even when there is a great productivity boon to be had. Two of these constructs are the dynamic array and the dispatch table, both common in modern, dynamically typed languages.  </p>
<p>The dynamic array is the simpler of the two concepts, and the most ubiquitous:</p>
<div class="highlight"><pre><span></span><span class="c1"># instantiate an array containing `1, 2, 3`</span>
<span class="k">my</span> <span class="nv">@array</span> <span class="o">=</span> <span class="sx">qw/1 2 3/</span><span class="p">;</span>
</pre></div>


<p>is a simple, contrived example of an array (or more pedantically, list,) of length 3 in Perl. Unlike C, if you want to change the length of the array, it would be as simple as:</p>
<div class="highlight"><pre><span></span><span class="c1"># instantiate an array containing `1, 2, 3`</span>
<span class="k">my</span> <span class="nv">@array</span> <span class="o">=</span> <span class="sx">qw/1 2 3/</span><span class="p">;</span>
<span class="c1"># append `4` and `5`</span>
<span class="nb">push</span> <span class="nv">@array</span><span class="p">,</span> <span class="mi">4</span><span class="p">;</span>
<span class="nb">push</span> <span class="nv">@array</span><span class="p">,</span> <span class="mi">5</span><span class="p">;</span>
<span class="c1"># pop `5` off the end</span>
<span class="nb">pop</span> <span class="nv">@array</span><span class="p">;</span>
<span class="c1"># shift `1` off the beginning</span>
<span class="nb">shift</span> <span class="nv">@array</span><span class="p">;</span>
<span class="c1"># prepend `1`</span>
<span class="nb">unshift</span> <span class="nv">@array</span><span class="p">,</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1"># prints `1, 2, 3, 4`</span>
<span class="k">print</span> <span class="nb">join</span> <span class="s">&#39; &#39;</span><span class="p">,</span> <span class="nv">@array</span><span class="p">;</span>
</pre></div>


<p>and you now have an array of length 4 containing <code>1, 2, 3, 4</code>.  </p>
<p>Easy, right? A dispatch table is a slightly more complex beast, but really not all that complicated either. A dispatch table is simply a table of functions which you can refer to by index to call:  </p>
<div class="highlight"><pre><span></span><span class="c1"># Define the table using one anonymous code-ref and one named code-ref</span>
<span class="k">my</span> <span class="nv">%dispatch</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">hi</span> <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span>  <span class="k">return</span> <span class="s">&#39;hello&#39;</span><span class="p">;</span> <span class="p">},</span>
    <span class="n">bye</span> <span class="o">=&gt;</span> <span class="o">\&amp;</span><span class="n">say_goodbye</span><span class="p">,</span>
<span class="p">);</span>

<span class="k">sub</span> <span class="nf">say_goodbye</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;goodbye&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1"># Fetch the code ref from the table, and invoke it</span>
<span class="k">print</span> <span class="nv">$dispatch</span><span class="p">{</span><span class="n">hi</span><span class="p">}</span><span class="o">-&gt;</span><span class="p">();</span>
<span class="k">print</span> <span class="nv">$dispatch</span><span class="p">{</span><span class="n">bye</span><span class="p">}</span><span class="o">-&gt;</span><span class="p">();</span>
</pre></div>


<p>which will simply call the subroutines indexed by the entries “hi” and “bye”.  </p>
<p>“Now this is all well and good, but this is Perl! I thought this post was about C?!” Ah, but it is! Although the code required to implement these constructs may not be quite the same, and a few semantics may be a bit different, it is indeed possible to implement these just as satisfactorily in C.  </p>
<p>To implement a dynamic array data structure, since C is a statically typed language, you have to pick what kind of data this will be an array of. To keep things simple, I will be demonstrating using an <code>int</code> lists but I have just as easily applied this same technique to string lists, <code>struct</code> lists, and even <code>void *</code> lists.  </p>
<p>A simple implementation in C would look something like this:  </p>
<p><strong>(This code depends only on the standard library; you are encouraged to compile and try it out yourself)</strong>  </p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="cm">/* struct definition for dynamic array */</span>
<span class="k">struct</span> <span class="n">int_list</span> <span class="p">{</span>
    <span class="cm">/* `size_t` members to keep track of current length and allocation size */</span>
    <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>
    <span class="cm">/* dynamically allocated array containing our data */</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* `malloc()` wrapper */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xmalloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sz</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* sanity check */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="cm">/* allocate or die */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">sz</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">msg</span> <span class="o">?</span> <span class="nl">msg</span> <span class="p">:</span> <span class="s">&quot;xrealloc()&quot;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* `calloc()` wrapper */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xcalloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sz</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* sanity check */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="cm">/* allocate or die */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">nmemb</span><span class="p">,</span> <span class="n">sz</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">msg</span> <span class="o">?</span> <span class="nl">msg</span> <span class="p">:</span> <span class="s">&quot;xcalloc()&quot;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* `realloc()` wrapper */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xrealloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sz</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
    <span class="cm">/* sanity check */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="cm">/* allocate or die */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">ptr</span><span class="p">,</span> <span class="n">sz</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">ptr</span><span class="p">);</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">msg</span> <span class="o">?</span> <span class="nl">msg</span> <span class="p">:</span> <span class="s">&quot;xrealloc()&quot;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* initilization of our dynamic array */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">array_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">int_list</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">list_struct</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* initialize current length to `0` and current size to `1` */</span>
    <span class="n">list_struct</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">list_struct</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">xcalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list_struct</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">list_struct</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="s">&quot;array_init()&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* append an integer to our array */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">array_append</span><span class="p">(</span><span class="k">struct</span> <span class="n">int_list</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">list_struct</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* increment length */</span>
    <span class="n">list_struct</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
    <span class="cm">/* realloc if `cnt` reaches current size */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">list_struct</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">list_struct</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* check if size too large */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list_struct</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">SIZE_MAX</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
        <span class="cm">/* reallocate double current size */</span>
        <span class="n">list_struct</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">xrealloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list_struct</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">list_struct</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">*</span> <span class="n">list_struct</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">,</span> <span class="s">&quot;array_append()&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/* append the value */</span>
    <span class="n">list_struct</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">list_struct</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* declare a dynamic array and initialize it */</span>
    <span class="k">struct</span> <span class="n">int_list</span> <span class="n">dyn_arr</span><span class="p">;</span>
    <span class="n">array_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dyn_arr</span><span class="p">);</span>

    <span class="cm">/* append `0, 1, 2, 3, 4` */</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">array_append</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dyn_arr</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

    <span class="cm">/* print out the values */</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dyn_arr</span><span class="p">.</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s[%zu] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;dyn_arr&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dyn_arr</span><span class="p">.</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="cm">/* free our list now that we are done */</span>
    <span class="n">free</span><span class="p">(</span><span class="n">dyn_arr</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>This may seem like more code than necessary, and it may well be, but doing your implementation in this manner allows you to easily reuse your code; say when you decide you want a list of strings (<code>char *</code>) instead of integers. All you have to do is a quick text substitution in a few places, and you have a fairly generic implementation that can be applied anywhere. In addition, since you allocate double the current size every time you call <code>realloc()</code>, you end up with an “amortized” dynamic array, which, in simple terms, means that when you append a value you end up only paying the cost of reallocation every power-of-two array length.  </p>
<p>The wrapping of the allocation functions allows to to simplify your error checking, while keeping the code around your allocations clean and uncluttered. Reducing the work you do may seem lazy, but in fact it is the best way to keep your code bug-free; the less chance you have of eliding important, though tedious, tasks such as check the return of <code>malloc()</code>, the less chance of human error in general.  </p>
<p>A dispatch table can also be implemented fairly easily in C using an array of function pointers. I recently used this data structure to vastly simplify the parsing of PGP packets, by have a dispatch table of constructor and destructor functions, which meant I could implement the parsing of a GnuPG key one packet at a time, and simply leave the other entries <code>NULL</code> until I got around to implementing them. Here is simplified version of my implementation.</p>
<p><strong>(This snippet, unfortunately, is not compilable, but the full source can be found at <a href="http://github.com/alyptik/derpgp">alyptik/derpgp</a>)</strong>:  </p>
<div class="highlight"><pre><span></span><span class="cm">/* dispatch table forward declaration */</span>
<span class="k">static</span> <span class="nf">size_t</span> <span class="p">(</span><span class="o">*</span><span class="k">const</span> <span class="n">dispatch_table</span><span class="p">[</span><span class="mi">64</span><span class="p">][</span><span class="mi">2</span><span class="p">])(</span><span class="n">PGP_PACKET</span> <span class="o">*</span><span class="kr">restrict</span><span class="p">);</span>

<span class="cm">/* function prototypes */</span>
<span class="kt">size_t</span> <span class="nf">parse_pubkey_packet</span><span class="p">(</span><span class="n">PGP_PACKET</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">packet</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="nf">parse_seckey_packet</span><span class="p">(</span><span class="n">PGP_PACKET</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">packet</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="nf">free_pubkey_packet</span><span class="p">(</span><span class="n">PGP_PACKET</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">packet</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="nf">free_seckey_packet</span><span class="p">(</span><span class="n">PGP_PACKET</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">packet</span><span class="p">);</span>

<span class="cm">/* dispatch each packet to a parser */</span>
<span class="kt">size_t</span> <span class="nf">parse_pgp_packets</span><span class="p">(</span><span class="n">PGP_LIST</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">pkts</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="cm">/* dispatch each packet to parsers */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pkts</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* get the type of the packet */</span>
        <span class="kt">int</span> <span class="n">packet_type</span> <span class="o">=</span> <span class="n">TAGBITS</span><span class="p">(</span><span class="n">pkts</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pheader</span><span class="p">);</span>
        <span class="cm">/* use the type as an index into the table of function pointers */</span>
        <span class="kt">size_t</span> <span class="p">(</span><span class="o">*</span><span class="k">const</span> <span class="n">parse_pkt</span><span class="p">)(</span><span class="n">PGP_PACKET</span> <span class="o">*</span><span class="kr">restrict</span><span class="p">)</span> <span class="o">=</span> <span class="n">dispatch_table</span><span class="p">[</span><span class="n">packet_type</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">parse_pkt</span><span class="p">)</span>
            <span class="n">parse_pkt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkts</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* free list of packets */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_pgp_list</span><span class="p">(</span><span class="n">PGP_LIST</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">pkts</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* return if passed NULL pointers */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pkts</span> <span class="o">||</span> <span class="o">!</span><span class="n">pkts</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pkts</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* get the type of the packet */</span>
        <span class="kt">int</span> <span class="n">packet_type</span> <span class="o">=</span> <span class="n">TAGBITS</span><span class="p">(</span><span class="n">pkts</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pheader</span><span class="p">);</span>
        <span class="cm">/* use the type as an index into the table of function pointers */</span>
        <span class="kt">size_t</span> <span class="p">(</span><span class="o">*</span><span class="k">const</span> <span class="n">cleanup_pkt</span><span class="p">)(</span><span class="n">PGP_PACKET</span> <span class="o">*</span><span class="kr">restrict</span><span class="p">)</span> <span class="o">=</span> <span class="n">dispatch_table</span><span class="p">[</span><span class="n">packet_type</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cleanup_pkt</span><span class="p">)</span>
            <span class="n">cleanup_pkt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkts</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">pkts</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pdata</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">pkts</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
    <span class="n">pkts</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">pkts</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">pkts</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* static function pointer array indexed by packet tag number */</span>
<span class="k">static</span> <span class="nf">size_t</span> <span class="p">(</span><span class="o">*</span><span class="k">const</span> <span class="n">dispatch_table</span><span class="p">[</span><span class="mi">64</span><span class="p">][</span><span class="mi">2</span><span class="p">])(</span><span class="n">PGP_PACKET</span> <span class="o">*</span><span class="kr">restrict</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">TAG_RSRVD</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>
    <span class="p">[</span><span class="n">TAG_PKESESS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>
    <span class="p">[</span><span class="n">TAG_SIG</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>
    <span class="p">[</span><span class="n">TAG_SKESESS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>
    <span class="p">[</span><span class="n">TAG_OPSIG</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>
    <span class="p">[</span><span class="n">TAG_SECKEY</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">parse_seckey_packet</span><span class="p">,</span> <span class="n">free_seckey_packet</span><span class="p">},</span>
    <span class="p">[</span><span class="n">TAG_PUBKEY</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">parse_pubkey_packet</span><span class="p">,</span> <span class="n">free_pubkey_packet</span><span class="p">},</span>
    <span class="p">[</span><span class="n">TAG_SECSUBKEY</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">parse_seckey_packet</span><span class="p">,</span> <span class="n">free_seckey_packet</span><span class="p">},</span>
    <span class="p">[</span><span class="n">TAG_CDATA</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>
    <span class="p">[</span><span class="n">TAG_SEDATA</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>
    <span class="p">[</span><span class="n">TAG_MARKER</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>
    <span class="p">[</span><span class="n">TAG_LITDATA</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>
    <span class="p">[</span><span class="n">TAG_TRUST</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>
    <span class="p">[</span><span class="n">TAG_UID</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>
    <span class="p">[</span><span class="n">TAG_PUBSUBKEY</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">parse_pubkey_packet</span><span class="p">,</span> <span class="n">free_pubkey_packet</span><span class="p">},</span>
    <span class="p">[</span><span class="n">TAG_UATTR</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>
    <span class="p">[</span><span class="n">TAG_SEIPDATA</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>
    <span class="p">[</span><span class="n">TAG_MDCODE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>
    <span class="p">[</span><span class="n">TAG_PRVT0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>
    <span class="p">[</span><span class="n">TAG_PRVT1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>
    <span class="p">[</span><span class="n">TAG_PRVT2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>
    <span class="p">[</span><span class="n">TAG_PRVT3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>
<span class="p">};</span>
</pre></div>


<p>Just like that, I suddenly have a modular, reusable system for dispatching to the relevant constructor and destructor functions. I can implement them at whatever pace works for me, and leave the unimplemented entries <code>NULL</code>. This allows a simple <code>if (ptr) {</code> check inside of a <code>for</code> loop to suffice for dispatching to all of the implemented functions in my table; safely, correctly, and most important of all, <strong>easily</strong>. Keeping your code simple and too the point, decoupling and isolating as many part of your program as possible, and keeping an open mind are crucial if you want to keep you code maintainable by others as well as yourself.  </p>
<p>Maybe you are an old, grizzled C veteran who cares not for all these fancy new languages, or maybe your aren't. Maybe C is a large part of your day-to-day career, or maybe you are just a C-hacker on the weekends. Regardless of your current relationship with C, it would be a grave mistake to ignore the innovations that other languages offer. It is an undisputed tautology that an open mind will always have an advantage over a closed one, and you will find that many useful data structures and algorithms from other programming languages are actually completely language-agnostic.  </p>
<p>So give it a shot; who knows, learning a little Perl or Python may, in fact, end up being the best decision you ever made.</p>
  </div>
  <div class="tag-cloud">
    <p>
    </p>
  </div>



    <div class="addthis_relatedposts_inline">


</article>

    <footer>
<!---
<p>
	&copy;  2017 - This work is licensed under a <a rel="license" href="http://opensource.org/licenses/BSD-2-Clause//">BSD 2-Clause License  International License</a>
	--->
<p>
	&copy;  2017 - This work is licensed under a <a rel="license" href="http://opensource.org/licenses/BSD-2-Clause">BSD 2-Clause License  International License</a>
</p>
<p>    Powered by <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a>
</p><p>
<!---
  <a rel="license"
     href="http://opensource.org/licenses/BSD-2-Clause//"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
         src="https://i.opensource.org/l/BSD-2-Clause//80x15.png"
         width="80"
	 height="15"/>
	 --->

  <a rel="license"
     href="http://opensource.org/licenses/BSD-2-Clause"
     target="_blank">
	<img alt="Simplified BSD License"
		title="Simplified BSD License"
		 style="border-width:0"
		 src="images/bsd.png"
		 height="60"/>
  </a>
</p>    </footer>
  </main>





<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Joey Pabalinas — caveat lector. ",
  "url" : "https://alyp.tk",
  "image": "https://alyp.tk/images/profile.png",
  "description": "anxiety is cheaper than cigarettes, love."
}
</script>

</body>
</html>