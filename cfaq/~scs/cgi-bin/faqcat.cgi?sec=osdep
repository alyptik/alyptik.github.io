<!DOCTYPE HTML PUBLIC "-//W3O//DTD W3 HTML 2.0//EN">
<!-- This collection of hypertext pages is Copyright 1995-2005 by Steve Summit. -->
<!-- Content from the book "C Programming FAQs: Frequently Asked Questions" -->
<!-- (Addison-Wesley, 1995, ISBN 0-201-84519-9) is made available here by -->
<!-- permission of the author and the publisher as a service to the community. -->
<!-- It is intended to complement the use of the published text -->
<!-- and is protected by international copyright laws. -->
<!-- The on-line content may be accessed freely for personal use -->
<!-- but may not be published or retransmitted without explicit permission. -->
<!-- -->
<!-- this page built Sat Dec 24 21:47:47 2005 by faqproc version 2.7 -->
<!-- from source file osdep.sgml dated Sat Nov 24 11:09:52 2001 -->
<!-- corresponding to FAQ list version 4.0 -->
<html>
<head>
<base href="http://c-faq.com/osdep/index.html">
<meta name=GENERATOR content="faqproc">
<title>System Dependencies</title>
</head>
<body bgcolor="#ffffff">
<H1>19. System Dependencies</H1>
<a name="cbreak">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/cbreak.html"><!-- qtag -->Question 19.1</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I read a single character from the keyboard without
waiting for
the RETURN key?
How can I stop characters from being
echoed

on the screen as they're typed?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>

Alas,



there is no standard or portable way to do
these things
in C.
Concepts such as screens
and keyboards are not even mentioned
in the Standard,
which deals only with simple I/O ``streams''
of characters.
</p><p>Input to a computer program
typically
passes through several stages.
At the lowest level,
device-dependent routines
within the operating system
handle the details of interfacing with particular devices
such as keyboards, serial lines, disk drives, etc.
Above that,
modern operating systems tend to have
a device-independent I/O layer,
unifying access
to any file or device.
Finally,
a C program is usually insulated
from the operating system's I/O facilities
by the portable functions of the stdio library.
</p><p>At some level,
interactive keyboard input is usually
collected 
and presented to the requesting program
a line at a time.
This gives the operating system a chance
to support input line editing
(backspace/delete/rubout, etc.)
in a consistent way,
without requiring that it
be built into every program.
Only when the user is satisfied and presses the RETURN key
(or equivalent)
is the line made available to the calling program.

Even if the calling program appears to be reading input
a character at a time
(with <TT>getchar</TT> or the like),
the first call

blocks until the user has typed an entire line,
at which point potentially many
characters become available
and many character requests
(e.g. <TT>getchar</TT> calls)
are satisfied in quick succession.
</p><p>When a program wants to
read each character immediately as it arrives,
its
course of action
will depend on
where in the input stream the line collection
is happening
and how it can be disabled.
Under some systems
(e.g. MS-DOS, VMS in some modes),
a program can use
a different
or modified
set of OS-level input calls
to bypass line-at-a-time input processing.
Under other systems
(e.g. Unix, VMS in other modes),
the part of the operating system responsible for serial input
(often called the ``terminal driver'')
must be placed in a mode which
turns off
line-at-a-time 
processing,
after which
all calls to
the usual input routines

(e.g. <TT>read</TT>,
<TT>getchar</TT>, etc.)
will return characters immediately.
Finally,
a few
systems
(particularly older, batch-oriented mainframes)
perform input processing
in

peripheral processors which cannot be told
to do anything other than line-at-a-time input.
</p><p>Therefore,
when you need to do character-at-a-time input
(or disable keyboard echo,
which
is an analogous problem),
you will
have to use a technique
specific to the system you're using,
assuming
it provides one.
Since comp.lang.c is oriented towards those topics
that the C language has
defined support for,
you will usually get better answers to other questions by 
referring to a system-specific newsgroup
such as
comp.unix.questions


or
comp.os.msdos.programmer,

and to the FAQ lists for these groups.
Note that the answers


may differ even across variants
of otherwise similar systems
(e.g. across different variants of Unix);
bear in mind when answering system-specific questions that the
answer that applies to your system may not apply to everyone else's.
</p><p>


However, since these questions are
frequently asked here,
here
are
brief answers
for some
common
situations.
</p><p>
Depending on
which operating system you're using
and

what libraries you have available,
you may be able to use one
(or more!)
of the following techniques:
</p><UL><li>If you can use the ``curses'' library,
you can call <TT>cbreak</TT>
<a href="crmode.html" rel=subdocument>[footnote]</a>
(and perhaps <TT>noecho</TT>),
after which calls to <TT>getch</TT>
will return characters immediately.
<li>If all you're trying to do is
read a short password without echo,
you
may be able to
use a function called <TT>getpass</TT>,
if it's available.
(Another possibility for hiding typed passwords
is to select black characters on a black background.)
<li>Under
``classic''
versions of
Unix,
use <TT>ioctl</TT>
and the TIOCGETP and TIOCSETP
(or TIOCSETN) requests
on file descriptor 0
to manipulate
the
sgttyb structure,
defined in <TT>&lt;sgtty.h&gt;</TT>
and documented in tty(4).
In the <TT>sg_flags</TT> field,
set the CBREAK
(or RAW) bit,
and perhaps clear the ECHO bit.
<li>Under System V Unix,

use <TT>ioctl</TT>
and the TCGETAW and TCSETAW requests
on file descriptor 0
to manipulate
the
termio structure,
defined in <TT>&lt;termio.h&gt;</TT>.
In the <TT>c_lflag</TT> field,
clear the ICANON
(and perhaps ECHO)
bits.
Also,
set
<TT>c_cc[VMIN]</TT> to 1 and <TT>c_cc[VTIME]</TT> to 0.
<li>Under any operating system
(Unix or otherwise)
offering POSIX compatibility,
use the <TT>tcgetattr</TT> and <TT>tcsetattr</TT> calls
on file descriptor 0
to manipulate
the
termios structure,
defined in <TT>&lt;termios.h&gt;</TT>.
In the
<TT>c_lflag</TT> field,
clear the ICANON
(and perhaps ECHO)
bits.
Also,
set
<TT>c_cc[VMIN]</TT> to 1 and <TT>c_cc[VTIME]</TT> to 0.
<li>In a pinch,
under Unix,
use <TT>system</TT>
(see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#system">19.27</a>)
to invoke the <TT>stty</TT> command
to set terminal driver
modes
(as in the preceding three items).
<li>Under
MS-DOS,
use <TT>getch</TT>
or <TT>getche</TT>,
or the corresponding
BIOS interrupts.
<li>Under VMS,
try the
Screen Management (SMG$) routines,
or curses,
or issue low-level $QIO's


with the IO$_READVBLK
function code
(and perhaps IO$M_NOECHO, and others)
to ask for one character at a time.
(It's also possible to set character-at-a-time
or ``pass through'' modes in the VMS terminal driver.)
<li>Under other operating systems, you're on your own.
</UL><p></p><p>(As an aside,
note that
simply
using <TT>setbuf</TT> or <TT>setvbuf</TT>
to set <TT>stdin</TT> to unbuffered

will <em>not</em> generally serve to allow character-at-a-time input.)
</p><p>


If you change terminal modes,
save
a copy
the initial state
and be sure to restore it no matter how your program terminates.
</p><p>If you're trying to write a portable program,
a good approach is to define your own suite of three functions to
(1)
set the
terminal driver
or
input system
into character-at-a-time mode
(if necessary),
(2)
get characters,
and
(3)
return the terminal driver
to its initial state
when the program is finished.
(Ideally, such a set of functions
might
be part of the C Standard, some day.)
</p><p>As an example,
here is a tiny test program
which prints the decimal values
of the next ten characters
as they are typed,
without waiting for RETURN.
It is
written in terms of three functions,
as described,
and is
followed by implementations of the three functions
for curses,
classic Unix,
System V Unix,
and MS-DOS.

(The on-line archives associated with this list
contain a
more complete set of functions.)
<pre>
#include &lt;stdio.h&gt;

main()
{
	int i;
	if(tty_break() != 0)
		return 1;
	for(i = 0; i &lt; 10; i++)
		printf(" = %d\n", tty_getchar());
	tty_fix();
	return 0;
}
</pre>
</p><p>This implementation
of the three functions
is for curses:
<pre>
#include &lt;curses.h&gt;

int tty_break()
{
	initscr();
	cbreak();
	return 0;
}

int tty_getchar()
{
	return getch();
}

int tty_fix()
{
	endwin();
	return 0;
}
</pre>
</p><p>Here is the code
for ``classic'' (V7, BSD) Unix:
<pre>
#include &lt;stdio.h&gt;
#include &lt;sgtty.h&gt;

static struct sgttyb savemodes;
static int havemodes = 0;

int tty_break()
{
	struct sgttyb modmodes;
	if(ioctl(fileno(stdin), TIOCGETP, &amp;savemodes) &lt; 0)
		return -1;
	havemodes = 1;
	modmodes = savemodes;
	modmodes.sg_flags |= CBREAK;
	return ioctl(fileno(stdin), TIOCSETN, &amp;modmodes);
}

int tty_getchar()
{
	return getchar();
}

int tty_fix()
{
	if(!havemodes)
		return 0;
	return ioctl(fileno(stdin), TIOCSETN, &amp;savemodes);
}
</pre>
</p><p>The code for System V Unix

is similar:
<pre>
#include &lt;stdio.h&gt;
#include &lt;termio.h&gt;

static struct termio savemodes;
static int havemodes = 0;

int tty_break()
{
	struct termio modmodes;
	if(ioctl(fileno(stdin), TCGETA, &amp;savemodes) &lt; 0)
		return -1;
	havemodes = 1;
	modmodes = savemodes;
	modmodes.c_lflag &amp;= ~ICANON;
	modmodes.c_cc[VMIN] = 1;
	modmodes.c_cc[VTIME] = 0;
	return ioctl(fileno(stdin), TCSETAW, &amp;modmodes);
}

int tty_getchar()
{
	return getchar();
}

int tty_fix()
{
	if(!havemodes)
		return 0;
	return ioctl(fileno(stdin), TCSETAW, &amp;savemodes);
}
</pre>
</p><p>Finally,
here is an
implementation for MS-DOS:

<pre>
int tty_break() { return 0; }

int tty_getchar()
{
	return getche();
}

int tty_fix() { return 0; }
</pre>
</p><p>Turning off echo
is left as an exercise for the reader.
</p><p>For detailed information on
terminal
(keyboard and screen)
I/O
programming,
see an FAQ list, book,
or documentation set specific to your operating system.
(Note that




there can be many more details to take care of,
e.g. special characters to disable
as well as
more mode bits to toggle,
than
were mentioned
above.)
</p><p>See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#readavail">19.2</a>.
</p><p>Additional links:
<a href="sd20.html" rel=subdocument>more solutions</a>
</p>



<p>References:

PCS Sec. 10 pp. 128-9, Sec. 10.1 pp. 130-1
<br>
POSIX Sec. 7
<hr><hr><hr>
<a name="readavail">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/readavail.html"><!-- qtag -->Question 19.2</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I find out
if there are characters
available for reading
(and if so, how many)?
Alternatively, how can I do a read that will not block if there
are no characters available?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
These, too, are entirely operating-system-specific.
Some versions of curses have a <TT>nodelay</TT> function.
Depending on your system, you may also be able to use
``nonblocking I/O'', or a system call named
<TT>select</TT>
or <TT>poll</TT>,
or the
FIONREAD
ioctl,
or
<TT>c_cc[VTIME]</TT>,
or <TT>kbhit</TT>,
or <TT>rdchk</TT>,
or the
O_NDELAY
option to <TT>open</TT> or <TT>fcntl</TT>.
You can also try setting an alarm
to cause a blocking read to time out after a certain interval
(under Unix,
look at <TT>alarm</TT>,
<TT>signal</TT>,
and maybe <TT>setitimer</TT>).

</p><p>If what you're trying to do is read input from several sources 
without blocking,
you will definitely want to use some kind of a ``select'' call,
because a busy-wait, polling loop is
terribly inefficient

on a 
multitasking system.
</p><p>See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#cbreak">19.1</a>.
<hr><hr><hr>
<a name="baton">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/baton.html"><!-- qtag -->Question 19.3</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I display a
percentage-done indication
that updates itself in place,
or show one of those
``twirling baton''
progress indicators?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
These simple things, at least, you can do fairly portably.

Printing
the
character <TT>'\r'</TT>
will usually give you
a 
carriage return
without a line feed, so that you can overwrite 
the current line.
The character
<TT>'\b'</TT>
is a backspace,
and will usually move the cursor one
position
to the left.
</p><p>Using these characters,
you can print a percentage-done indicator:
<pre>
	for(i = 0; i &lt; lotsa; i++) {
		printf("\r%3d%%", (int)(100L * i / lotsa));
		fflush(stdout);
		do_timeconsuming_work();
	}
	printf("\ndone.\n");
</pre>
or a baton:
<pre>
	printf("working: ");
	for(i = 0; i &lt; lotsa; i++) {
		printf("%c\b", "|/-\\"[i%4]);
		fflush(stdout);
		do_timeconsuming_work();
	}
	printf("done.\n");
</pre>
</p><p>See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=stdio#fflush">12.4</a>.
</p>
<p>References:

ISO Sec. 5.2.2
<hr><hr><hr>
<a name="termcap">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/termcap.html"><!-- qtag -->Question 19.4</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I clear the screen?
<br>How can I
print
text in color?
<br>
How can I
move the cursor
to a specific x,&nbsp;y position?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Such things depend on the
terminal type (or display)
you're using.
You will have to use a library such as
termcap, terminfo, or curses,
or some system-specific routines, to perform these operations.
</p><p>Functions
in the curses library
to look for are
<TT>clear</TT>,
<TT>move</TT>,
<TT>standout</TT>/<TT>standend</TT>,
and
<TT>attron</TT>/<TT>attroff</TT>/<TT>attrset</TT>;
the last three work with
attribute codes such as A_REVERSE.
In MS-DOS libraries,
there are typically functions named
<TT>gotoxy</TT>
and
<TT>clrscr</TT>
or
<TT>_clearscreen</TT>;
you can also use the ANSI.SYS driver or low-level interrupts.
Under termcap or terminfo,
use <TT>tgetstr</TT>
to retrieve strings like
<TT>cl</TT>,
<TT>so</TT>/<TT>se</TT>,
and <TT>cm</TT>
for clear screen, standout mode, and cursor motion respectively,
then output the strings;
using <TT>cm</TT> additionally requires calling <TT>tgoto</TT>.




Some baroque terminals require
attention to other ``capabilities'' as well;
study the
documentation carefully.
Be aware that some older terminals
may
not support the desired capabilities
at all.
</p><p>Most modern terminal emulation schemes
support the ANSI escape sequences
for cursor motion and visual attributes,
so if you're willing to sacrifice portability,
you can print those sequences directly.
Here is a tiny example to whet your appetite:
<pre>
printf("\033[2J");		/* clear screen */
printf("\033[%d;%dH", 10, 20);	/* move cursor (row 10, col 20) */
printf("Hello, ");
printf("\033[7mworld\033[0m!");	/* inverse video */
</pre>
Here is a link to some
<a href="sd21.html" rel=subdocument>more explanation, and brief lists of codes.</a>
The portable way of emitting these sequences
(if you're not going whole-hog and using curses)
is to use termcap or terminfo;
here is
<a href="sd22.html" rel=subdocument>an example.</a>
</p><p>For clearing the screen,
a halfway portable solution is to print
a form-feed character
(<TT>'\f'</TT>),
which will cause
some
displays
to clear.
Even more portable
(albeit even more gunky)
might be
to print enough newlines
to scroll everything away
(although of course
this leaves the cursor at the bottom of the screen,
not the top).
As a last resort,
you could use <TT>system</TT>
(see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#system">19.27</a>)
to invoke
an operating system clear-screen command.

</p>

<p>References:

PCS Sec. 5.1.4 pp. 54-60, Sec. 5.1.5 pp. 60-62
<br>
Strang, <I>Programming with curses</I>

<br>
Strang, Mui, and O'Reilly, <I>termcap &amp; terminfo</I>

<hr><hr><hr>
<a name="waitforkey">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/waitforkey.html"><!-- qtag -->Question 19.4b</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
I'm compiling some test programs on a windows-based system,
and the windows containing my program's output
are closing so quickly
after my program calls <TT>exit</TT>
that I can't see the output.
How can I make it pause before closing?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
After wondering why the author of your compiler's run-time system
didn't take care of this for you,
simply add the lines
<pre>
	printf("Hit RETURN to exit"\n");
	fflush(stdout);
	(void)getchar();
</pre>
just before the end of your program.
(If you want to wait for any keystroke,
not just the RETURN key,
see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#cbreak">19.1</a>.)
<hr><hr><hr>
<a name="specialkeys">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/specialkeys.html"><!-- qtag -->Question 19.5</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How do I read the arrow keys?
What about function keys?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Terminfo,
some versions of termcap,
and some versions of curses
have support for these non-ASCII keys.
Typically,
a special key sends a multicharacter sequence
(usually beginning with ESC, <TT>'\033'</TT>);

parsing these can be tricky.
(curses will do the parsing for you,
if you call <TT>keypad</TT> first.)
</p><p>Under MS-DOS, if you receive a
character with
value 0
(<em>not</em> <TT>'0'</TT>!)
while reading the keyboard,
it's a flag indicating
that the next character read will be a code indicating a 
special key.
See any DOS programming guide for lists of keyboard scan codes.
(Very briefly:
the up, left, right, and down arrow keys are 72, 75, 77, and 80,
and the function keys

are 59 through 68.)
</p>
<p>References:

PCS Sec. 5.1.4 pp. 56-7
<hr><hr><hr>
<a name="mouse">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/mouse.html"><!-- qtag -->Question 19.6</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How do I read the mouse?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Consult your system documentation,
or ask on an appropriate system-specific newsgroup
(but check its FAQ list first).
Mouse handling is completely different under the
X window system,
MS-DOS,
the Macintosh,
and probably every other system.
</p>
<p>References:

PCS Sec. 5.5 pp. 78-80
<hr><hr><hr>
<a name="serial">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/serial.html"><!-- qtag -->Question 19.7</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I do serial (``comm'') port I/O?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
It's system-dependent.
Under Unix,
you typically open, read, and write
a device file in <TT>/dev</TT>,
and use the
facilities of the terminal driver
to adjust its characteristics.
(See also questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#cbreak">19.1</a>
and <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#readavail">19.2</a>.)
Under MS-DOS, you can
use
the predefined stream <TT>stdaux</TT>,
or a special file like COM1,
or
some primitive BIOS interrupts,
or (if you require
decent
performance)

any number of interrupt-driven serial I/O packages.
Several
netters
recommend the book
<I>C Programmer's Guide to Serial Communications</I>,
by Joe Campbell.
<hr><hr><hr>
<a name="printer">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/printer.html"><!-- qtag -->Question 19.8</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I direct output to the printer?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Under Unix,
either use <TT>popen</TT>
(see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#popen">19.30</a>)
to write to the
<TT>lp</TT>
or
<TT>lpr</TT> program,
or perhaps open

a special file like <TT>/dev/lp</TT>.
Under MS-DOS, write to the
(nonstandard)
predefined stdio stream <TT>stdprn</TT>,
or open the special files PRN or LPT1.
Under some circumstances,
another
(and perhaps the only)
possibility is to use a window manager's screen-capture function,
and print the resulting bitmap.

</p>
<p>References:

PCS Sec. 5.3 pp. 72-74
<hr><hr><hr>
<a name="escseqs">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/escseqs.html"><!-- qtag -->Question 19.9</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How do I send escape sequences
to control a terminal or other 
device?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
If you can figure out how to send characters to the device at all
(see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#printer">19.8</a>),
it's easy enough to send escape sequences.
In ASCII,
the ESC code is 033
(27 decimal),
so
code like
<pre>
	fprintf(ofd, "\033[J");
</pre>
sends the sequence <TT>ESC&nbsp;[&nbsp;J

.
</TT></p><p>Some programmers prefer to parameterize the ESC code,
like this:
<pre>
	#define ESC 033

	fprintf(ofd, "%c[J", ESC);
</pre>
<hr><hr><hr>
<a name="portio">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/portio.html"><!-- qtag -->Question 19.9b</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I access an I/O board directly?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
At one level, at least, it's quite simple: you have a device
register which is actually wired up so that the bits written to
it get coverted to actual voltage levels in the real world that
you can do interesting things with.
In general, there are two ways to
get the bits in and out.
(A particular I/O board will
use one method or the other;
you'll need to consult its documentation for details.)
<OL><li>If the device is accessed via a dedicated ``I/O port'',
use system-specific functions
to communicate with it.
Under MS-DOS, for example, there were quasistandard
``inport'' and ``outport''
instructions.
<li>If the device uses ``memory-mapped I/O'',
that is,
if the device register(s) are accessed as if they were normal memory
at particular, known locations within the processor's addressing space,
use contrived pointer variables to access
those
locations.
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#rawmemadr">19.25</a>.
<hr><hr><hr>
<a name="graphics">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/graphics.html"><!-- qtag -->Question 19.10</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I do graphics?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Once upon a time,
Unix
had a fairly nice little set of device-independent plot
functions described in plot(3) and plot(5).
The GNU libplot
library,
written by
<a href="http://uranium.math.arizona.edu/~rsm/">Robert Maier</a>,
maintains
the same spirit
and supports many modern plot devices;
see
<a href="http://www.gnu.org/software/plotutils/plotutils.html"><TT>http://www.gnu.org/software/plotutils/plotutils.html</TT></a>.
</p><p>A modern, platform-independent graphics library
(which also supports 3D graphics and animation)
is OpenGL.
Other graphics standards which may be of interest are GKS and PHIGS.

</p><p>If you're programming for MS-DOS,
you'll probably
want to use libraries
conforming to the VESA or BGI
standards.
</p><p>If you're trying to talk to a particular plotter,
making it draw is usually a matter of sending it the appropriate
escape sequences;
see also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#escseqs">19.9</a>.
The vendor may supply a C-callable library,
or you may be able to find one on the net.
</p><p>If you're programming for a particular
window system
(Macintosh, X windows, Microsoft Windows),
you will use its facilities;
see the relevant
documentation
or
newsgroup
or
FAQ list.
</p>
<p>References:

PCS Sec. 5.4 pp. 75-77
<hr><hr><hr>
<a name="gifjpeg">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/gifjpeg.html"><!-- qtag -->Question 19.10b</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I
display GIF and JPEG images?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
It
will depend
on your display environment,
which may already provide

these functions.
Reference JPEG software is at
<a href="http://www.ijg.org/files/"><TT>http://www.ijg.org/files/</TT></a>.

<hr><hr><hr>
<a name="fonts">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/fonts.html"><!-- qtag -->Question 19.10c</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I load new fonts for display?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
It's system-dependent.
<hr><hr><hr>
<a name="sendmail">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/sendmail.html"><!-- qtag -->Question 19.10d</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I send mail from within a C program?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Under Unix,
open
a pipe to the <TT>mail</TT> program,
or perhaps <TT>/usr/lib/sendmail</TT>.
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#popen">19.30</a>.
<hr><hr><hr>
<a name="fileexists">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/fileexists.html"><!-- qtag -->Question 19.11</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I check whether a file exists?
I want to
warn the user
if a requested input file is missing.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
It's surprisingly difficult to
make this determination
reliably and portably.
Any test you make can be invalidated
if the file is created or deleted
(i.e.
by some other process)
between the time you make the test
and the time you try to open the file.
</p><p>Three possible test functions are
<TT>stat</TT>,
<TT>access</TT>,
and
<TT>fopen</TT>.
(To
make an approximate
test
using
<TT>fopen</TT>,
just open for reading and close immediately,
although failure does not necessarily indicate nonexistence.)
Of these,
only <TT>fopen</TT> is widely portable,
and <TT>access</TT>,
where it exists,
must be used carefully if
the program
uses the Unix
set-UID
feature.






(If you have the choice,
the best compromise
is probably one of the <TT>stat</TT> functions.)
</p><p>Rather than trying to predict in advance
whether an operation
such as opening a file
will succeed,
it's often better to

try it,
check the return value,
and complain if it
fails.
(Obviously, this approach won't work
if you're trying to avoid overwriting an
existing file, unless you've got something like the
<TT>O_EXCL</TT>
file opening
option available,
which does just what you want
in
this
case.)
</p>



<p>References:

PCS Sec. 12 pp. 189,213
<br>
POSIX Sec. 5.3.1, Sec. 5.6.2, Sec. 5.6.3
<hr><hr><hr>
<a name="filesize">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/filesize.html"><!-- qtag -->Question 19.12</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I find out the size of a file,
prior to reading it in?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>

If the ``size of a file''
is the number of characters you'll be able to read from it
in C
(or which were written to it by a previous program),
it
can be
difficult
or
impossible
to determine this number
exactly



(other than
by reading the whole file).
</p><p>Under
Unix,
the <TT>stat</TT> call
(specifically,
the <TT>st_size</TT> field of the stat structure)
will give you an exact answer.
<a href="concur2.html" rel=subdocument>[footnote]</a>
Several other systems supply a
Unix-like
<TT>stat</TT>
call,
but the sizes reported for text files
may be approximate
(due to differing end-of-line representations;
see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=stdio#textvsbinary">12.40</a>).
You can
open the file and use <TT>fstat</TT>,
or
<TT>fseek</TT> to the end
of the file
and then use <TT>ftell</TT>,
but

these tend to have
the same
problems:
<TT>fstat</TT> is not portable,
and generally tells you the same thing <TT>stat</TT> tells you;
<TT>ftell</TT> is not guaranteed to return a byte count
except for binary files









(but,
strictly speaking,
binary files don't necessarily support <TT>fseek</TT> to <TT>SEEK_END</TT>
at all).



Some systems
provide functions called
<TT>filesize</TT>
or <TT>filelength</TT>,
but these are obviously not portable, either.
</p><p>Are you sure you have to determine the file's size in advance?
Since the most accurate way of determining the size of a file as
a C program will see it is to
open the file
and read it,
perhaps you can rearrange the code to learn the size as it reads.
(In general, your program
should behave
gracefully
if
the
number of characters
actually
read
does not
match
prior expectations,
since any advance determination of the size might be approximate.)
See also questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=malloc#realloc">7.29</a>,
<a href="/~scs/cgi-bin/faqcat.cgi?sec=malloc#reallocnull">7.30</a>,
and <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#ragged">20.2</a>.
</p><p>Additional links:
<a href="sd23.html" rel=subdocument>further reading</a>
</p>



<p>References:

ISO Sec. 7.9.9.4
<br>
H&amp;S Sec. 15.5.1
<br>
PCS Sec. 12 p. 213
<br>
POSIX Sec. 5.6.2
<hr><hr><hr>
<a name="modtime">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/modtime.html"><!-- qtag -->Question 19.12b</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I find the modification date
and time
of a file?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
The Unix and POSIX function is <TT>stat</TT>,
which several other systems supply as well.
(See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#filesize">19.12</a>.)
<hr><hr><hr>
<a name="ftruncate">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/ftruncate.html"><!-- qtag -->Question 19.13</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can a file be shortened in-place without completely clearing
or rewriting it?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
BSD systems provide <TT>ftruncate</TT>,
several others supply <TT>chsize</TT>,
and a few may provide a
(possibly undocumented)
<TT>fcntl</TT> option
F_FREESP.
Under MS-DOS,
you can sometimes use <TT>write(fd,&nbsp;"",&nbsp;0)</TT>.
However,
there is no portable solution,
nor a way to delete blocks at the beginning
or in the middle.
See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#insdelrec">19.14</a>.
<hr><hr><hr>
<a name="insdelrec">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/insdelrec.html"><!-- qtag -->Question 19.14</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I insert or delete a line
(or record)
in the middle of a file?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
In general, there is no way to
do this.
<a href="nonseq.html" rel=subdocument>[footnote]</a>
The usual solution is simply to rewrite the file.
</p><p>When you find yourself needing to insert data
into an existing file,
here are a few alternatives you can try:

</p><UL><li>Rearrange the data file so that you can append the new 
information at the end.
<li>Put the information in a second file.

<li>Leave some blank space
(e.g. a line of 80 spaces,
or a field like <TT>0000000000</TT>)
in the file when it is first written,
and overwrite it
later
with the final
information
(see also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=stdio#fupdate">12.30</a>).

(This technique is most portable in binary mode;
on some systems,
overwriting a text file may truncate it.)
<li>Use a database

instead of a flat file.
</UL><p>Instead of actually deleting records,
you might consider
just marking them as deleted,
and having the code which reads the file ignore them.

(You could run a separate
coalescion
program once in a while
to rewrite the file,
finally
discarding
the deleted records.




Or,
if the records are all the same length,
you could take the last record
and use it to overwrite the record to be deleted,
then truncate the file.)
</p><p>See also questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=stdio#fupdate">12.30</a>
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#ftruncate">19.13</a>.
</p><p>Additional links:
<a href="insertf.20000216.html">further reading</a>
<hr><hr><hr>
<a name="fdfilename">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/fdfilename.html"><!-- qtag -->Question 19.15</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I recover the file name given an open
stream
or
file descriptor?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
This problem is, in general, insoluble.
Under
Unix,
for instance,
a scan of the entire disk
(perhaps involving special permissions)
would theoretically be required,
and would fail if the
descriptor
were
connected to a pipe
or referred to a deleted file
(and
could give a misleading answer for a file with multiple links).
It is best to remember
the names
of files yourself
as
you open them

(perhaps with

a wrapper function around
<TT>fopen</TT>).
<hr><hr><hr>
<a name="delete">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/delete.html"><!-- qtag -->Question 19.16</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I delete a file?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
The Standard C Library function is
<TT>remove</TT>.
(This is therefore one of the few questions in this section
for which the answer is <em>not</em>
``It's system-dependent.'')
On older,
pre-ANSI
Unix systems,
<TT>remove</TT> may not exist,
in which case you can try
<TT>unlink</TT>.
<a href="unlink.html" rel=subdocument>[footnote]</a>
</p>





<p>References:

K&amp;R2 Sec. B1.1 p. 242
<br>
ISO Sec. 7.9.4.1
<br>
H&amp;S Sec. 15.15 p. 382
<br>
PCS Sec. 12 pp. 208,220-221
<br>
POSIX Sec. 5.5.1, Sec. 8.2.4
<hr><hr><hr>
<a name="copy">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/copy.html"><!-- qtag -->Question 19.16b</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How do I copy files?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Either use <TT>system()</TT>
to invoke your operating system's copy utility
(see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#system">19.27</a>),
or open
the source and destination files
(using <TT>fopen</TT> or some lower-level file-opening system call),
read characters or blocks of characters from the source file,

and write them to the destination file.
Here is a simple example:
<pre>
#include &lt;stdio.h&gt;

int copyfile(char *fromfile, char *tofile)
{
	FILE *ifp, *ofp;
	int c;

	if((ifp = fopen(fromfile, "r")) == NULL) return -1;
	if((ofp = fopen(tofile, "w")) == NULL) { fclose(ifp); return -1; }

	while((c = getc(ifp)) != EOF)
		putc(c, ofp);

	fclose(ifp);
	fclose(ofp);

	return 0;
}
</pre>
To copy a block at a time, rewrite the inner loop as
<pre>
	while((r = fread(buf, 1, sizeof(buf), ifp)) &gt; 0)
		fwrite(buf, 1, r, ofp);
</pre>
where <TT>r</TT> is an <TT>int</TT>
and <TT>buf</TT> is a suitably-sized array of <TT>char</TT>.
</p>

<p>References:

K&amp;R Sec. 1, Sec. 7
<hr><hr><hr>
<a name="dospath">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/dospath.html"><!-- qtag -->Question 19.17</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Why can't I open a file by its explicit path?
The
call
<pre>
fopen("c:\newdir\file.dat",&nbsp;"r")</pre>

is failing.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
The file you actually requested--with
the characters <TT>\n</TT> and <TT>\f</TT> in its
name--probably
doesn't exist,
and isn't what you thought you were trying to open.
</p><p>In character constants and string literals,
the backslash <TT>\</TT> is an escape character,
giving special meaning to the character following it.
In order
for
literal backslashes in
a pathname to
be
passed through to <TT>fopen</TT>
(or any other function)
correctly,
they have to be doubled,
so that the first
backslash in each pair
quotes the second one:
<pre>
	fopen("c:\\newdir\\file.dat", "r")
</pre>
Alternatively,
under MS-DOS,
it turns out that
forward slashes are also 
accepted as directory separators,
so you could use
<pre>
	fopen("c:/newdir/file.dat", "r")
</pre>
(Note, by the way, that
header file names
mentioned in
preprocessor <TT>#include</TT> directives

are <em>not</em> string 
literals,
so you may not have to worry about backslashes there.)
<hr><hr><hr>
<a name="fopenenv">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/fopenenv.html"><!-- qtag -->Question 19.17b</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
<TT>fopen</TT> isn't letting me open files like
<TT>"$HOME/.profile"</TT>
and
<TT>"~/.myrcfile"</TT>.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Under Unix, at least,
environment variables like <TT>$HOME</TT>,
along with the home-directory notation involving the <TT>~</TT> character,
are expanded by the shell,
and there's no mechanism to perform these expansions
automatically when you call <TT>fopen</TT>.

<hr><hr><hr>
<a name="abrtretrign">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/abrtretrign.html"><!-- qtag -->Question 19.17c</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I suppress the
dreaded MS-DOS
``Abort, Retry, Ignore?'' message?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>




Among other things,
you need to intercept the DOS Critical Error Interrupt,
interrupt 24H.
See the comp.os.msdos.programmer FAQ list

for more details.

<hr><hr><hr>
<a name="nfile">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/nfile.html"><!-- qtag -->Question 19.18</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
I'm getting an error,
``Too many open files''.
How can I increase the allowable number of simultaneously open files?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
There are typically
at least
two resource limitations on the number of simultaneously open files:

the number of low-level ``file descriptors'' or 
``file handles'' available in the operating system, 
and the number of <TT>FILE</TT> structures available in the stdio 
library.
Both must be sufficient.
Under MS-DOS systems,
you can control the number of operating 
system file handles with a line in CONFIG.SYS.

Some compilers come with instructions (and perhaps a source 
file or two) for increasing the number of stdio <TT>FILE</TT> 
structures.
</p><p>Additional links:
<a href="sd24.html" rel=subdocument>further reading</a>
<hr><hr><hr>
<a name="diskfree">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/diskfree.html"><!-- qtag -->Question 19.19</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I find out how much free space
is available on disk?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
There is no portable way.
Under some versions of Unix
you can call <TT>statfs</TT>.
Under MS-DOS,
use interrupt 0x21 subfunction 0x36,
or perhaps a routine such as
<TT>diskfree</TT>.
Another possibility is to use
<TT>popen</TT>
(see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#popen">19.30</a>)
to invoke and read the output of a ``disk free'' command
(<TT>df</TT> on Unix).
</p><p>(Note that the amount of free space apparently available on a disk
may not match the
size of the largest file
you can store,
for all sorts of reasons.)
<hr><hr><hr>
<a name="readdir">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/readdir.html"><!-- qtag -->Question 19.20</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I read a directory in a C program?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
See if you can use
the
<TT>opendir</TT> and <TT>readdir</TT>
functions,
which are
part of the POSIX standard
and are
available on most
Unix
variants.
Implementations also exist for
MS-DOS,
VMS,
and other systems.
(MS-DOS also has
FINDFIRST and FINDNEXT

routines
which do
essentially the same thing,
and




MS Windows has
<TT>FindFirstFile</TT> and <TT>FindNextFile</TT>.)
<TT>readdir</TT>
returns just the
file names;
if you need more information about the file,
try calling <TT>stat</TT>.
To match filenames to some wildcard pattern,
see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=lib#regex">13.7</a>.
</p><p>Here is a tiny example which lists the files in the current directory:
<pre>
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;

main()
{
	struct dirent *dp;
	DIR *dfd = opendir(".");
	if(dfd != NULL) {
		while((dp = readdir(dfd)) != NULL)
			printf("%s\n", dp-&gt;d_name);
		closedir(dfd);
	}
	return 0;
}
</pre>
(On older systems, the header file to <TT>#include</TT> may be 
<TT>&lt;direct.h&gt;</TT> or <TT>&lt;dir.h&gt;</TT>,
and the pointer returned by <TT>readdir</TT> may be a 
<TT>struct&nbsp;direct&nbsp;*</TT>.
This example assumes that <TT>"."</TT> is a synonym for the 
current directory.)
</p><p>In a pinch, you could use
<TT>popen</TT>
(see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#popen">19.30</a>)
to call an operating system list-directory program,
and read its output.
(If you only need the filenames displayed to the user,
you could conceivably use <TT>system</TT>;
see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#system">19.27</a>.)
</p>




<p>References:

K&amp;R2 Sec. 8.6 pp. 179-184
<br>
PCS Sec. 13 pp. 230-1
<br>
POSIX Sec. 5.1
<br>
Schumacher, ed., <I>Software Solutions in C</I> Sec. 8
<hr><hr><hr>
<a name="mkdir">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/mkdir.html"><!-- qtag -->Question 19.21</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How do I create a directory?
<br>How do I remove a directory
(and its contents)?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
If your operating system supports
these services,
they are
likely to be
provided
in C
via
functions
named
<TT>mkdir</TT> and
<TT>rmdir</TT>.
Removing a directory's contents as well will require listing 
them
(see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#readdir">19.20</a>)
and calling <TT>remove</TT>
(see also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#delete">19.16</a>).
If you don't have these C functions
available,
try <TT>system</TT>
(see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#system">19.27</a>)
along
with


your operating system's delete command(s).
</p>

<p>References:

PCS Sec. 12 pp. 203-4
<br>
POSIX Secs. 5.4.1,5.5.2
<hr><hr><hr>
<a name="memavail">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/memavail.html"><!-- qtag -->Question 19.22</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I find out how much memory is available?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Your operating system may provide a routine which returns this 
information,
but it's quite system-dependent.
(Also, the number may vary over time.)
If you're trying to predict whether
you'll be able to
allocate
a certain amount of memory,
just try it--call
<TT>malloc</TT>
(requesting that amount)
and check
the
return value.

<hr><hr><hr>
<a name="bigdatastr">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/bigdatastr.html"><!-- qtag -->Question 19.23</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I allocate arrays or structures bigger than 64K?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
A reasonable
computer
ought to
give you transparent access
to all available memory.
If you're
not so lucky,
you'll either have to rethink your program's use of memory,
or use various system-specific techniques.
</p><p>64K is
(still)
a pretty
big chunk of memory.
No matter how much memory your computer
has available,
it's asking a lot to be able to allocate huge amounts of
it
contiguously.
(The C Standard does not guarantee that
single objects can be 32K or larger,

or 64K for C99.)
Often it's a good idea to use data
structures which don't 
require that all memory be contiguous.
For dynamically-allocated multidimensional arrays,
you can
use pointers to pointers,
as illustrated in
questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#dynmuldimary">6.16</a> and <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#ragged">20.2</a>.
Instead of a large array of structures,
you can use a linked list,
or an array of pointers to structures.
</p><p>If you're using a
PC-compatible
(8086-based)
system,
and running up against a

64K or
640K limit,
consider using
``huge'' memory model,
or expanded or extended

memory,
or malloc variants such as <TT>halloc</TT>
or <TT>farmalloc</TT>,
or a 32-bit
``flat'' compiler
(e.g. djgpp,
see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=resources#compilers">18.3</a>),
or some kind of a DOS extender,
or another operating system.
</p>

<p>References:

ISO Sec. 5.2.4.1
<br>
C9X Sec. 5.2.4.1
<hr><hr><hr>
<a name="dgroup">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/dgroup.html"><!-- qtag -->Question 19.24</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What does the error message
``DGROUP
data allocation
exceeds 64K''
mean,
and what can I do about it?
I thought that using large model meant that I could use
more than 64K of data!
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Even in large memory models,
MS-DOS compilers apparently toss certain data
(strings, some initialized global or <TT>static</TT> variables)
into a default data segment,
and it's this segment that is overflowing.
Either use less global data,
or,
if you're already limiting yourself to reasonable amounts
(and if the problem is due to something like the number of strings),

you may be able to coax the compiler
into not using the default data segment for so much.
Some compilers place only ``small'' data objects
in the default data segment,
and give you a way
(e.g. the <TT>/Gt</TT> option under Microsoft compilers)
to configure the threshold for ``small.''
<hr><hr><hr>
<a name="rawmemadr">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/rawmemadr.html"><!-- qtag -->Question 19.25</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I access memory
(a memory-mapped device,
or graphics memory)
located at a certain address?
<br>How can I do PEEK and POKE in C?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Set a pointer,
of the appropriate type,
to the right number
(using an explicit cast
to assure the compiler
that you really do intend this nonportable conversion):
<pre>
	unsigned int *magicloc = (unsigned int *)0x12345678;
</pre>
Then, <TT>*magicloc</TT> refers to the location you want.
<a href="fn92.html" rel=subdocument>[footnote]</a>




If the location is a memory-mapped I/O register,
you will probably also want to use
the <TT>volatile</TT> qualifier:
``<TT>volatile&nbsp;unsigned&nbsp;int&nbsp;*magicloc</TT>''.

(If you want to refer to a byte at a certain address
rather than a word,
use <TT>unsigned&nbsp;char&nbsp;*</TT>.)
</p><p>Under
MS-DOS,
you may find a macro like <TT>MK_FP()</TT>
handy
for working with segments and
offsets.
As suggested by Gary Blaine,
you can also declare tricky array pointers which allow you to 
access screen memory using array
notation.
For example,
on an MS-DOS machine
in an 80x25 text mode,
given the declaration
<pre>
unsigned short (far * videomem)[80] =
		(unsigned short (far *)[80])0xb8000000;
</pre>
you can access the character and attribute byte
at row <TT>i</TT>, column <TT>j</TT>
with <TT>videomem[i][j]</TT>.
</p><p>


Many

operating systems execute user-mode programs
in a protected mode
where direct access to I/O devices
(or to <em>any</em> address outside the running process)
is simply not possible.
In such cases you
will
have to ask the operating system
to carry out I/O operations for you.
</p><p>See also questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=ptrs#int2ptr">4.14</a>
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=null#accessloc0">5.19</a>.
</p>




<p>References:

K&amp;R1 Sec. A14.4 p. 210
<br>
K&amp;R2 Sec. A6.6 p. 199
<br>
ISO Sec. 6.3.4
<br>
Rationale Sec. 3.3.4
<br>
H&amp;S Sec. 6.2.7 pp. 171-2
<hr><hr><hr>
<a name="endiantest">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/endiantest.html"><!-- qtag -->Question 19.25b</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I determine whether a machine's
byte order
is big-endian or little-endian?
</p>
<p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#endiantest">20.9</a>.
<hr><hr><hr>
<a name="accessloc0">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/accessloc0.html"><!-- qtag -->Question 19.26</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I access
an interrupt vector
located at
the machine's location 0?
If I set a pointer to <TT>0</TT>,
the compiler might translate it to some nonzero internal null
pointer value.
</p>
<p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=null#accessloc0">5.19</a>.
<hr><hr><hr>
<a name="system">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/system.html"><!-- qtag -->Question 19.27</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I invoke
another program
(a standalone executable,
or an operating system command)
from within a C program?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Use
the library function
<TT>system</TT>,
which does exactly that.
</p><p>Some systems also provide a family of <TT>spawn</TT>
routines which accomplish
approximately the same thing.
<TT>system</TT> is more ``portable''
in that it is required under the ANSI C Standard,
although the interpretation of the command
string--its
syntax and the set of commands
accepted--will
obviously vary tremendously.
</p><p>The
<TT>system</TT>
function

``calls''
a command in the manner of 
a subroutine,
and control
eventually
returns to the calling program.
If you want to overlay the calling program with another program
(that is,
a ``chain'' operation)
you'll need a
system-specific routine,
such as the <TT>exec</TT> family on Unix.
</p><p>Note
that <TT>system</TT>'s return value
is
at best
the command's exit status
(although even that is not guaranteed),
and usually has nothing to do with the output of the command.
</p><p>See also
questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#system2">19.28</a>
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#popen">19.30</a>.
</p>







<p>References:

K&amp;R1 Sec. 7.9 p. 157
<br>
K&amp;R2 Sec. 7.8.4 p. 167, Sec. B6 p. 253
<br>
ISO Sec. 7.10.4.5
<br>
H&amp;S Sec. 19.2 p. 407
<br>
PCS Sec. 11 p. 179
<hr><hr><hr>
<a name="system2">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/system2.html"><!-- qtag -->Question 19.28</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I call <TT>system</TT> when parameters
(filenames, etc.)
of the executed command
aren't known until run time?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Just use <TT>sprintf</TT>
(or perhaps <TT>strcpy</TT> and <TT>strcat</TT>)
to build the command string in a
buffer,
then call <TT>system</TT> with that 
buffer.
(Make sure the buffer is allocated with enough space;
see also questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=malloc#malloc2">7.2</a> and <a href="/~scs/cgi-bin/faqcat.cgi?sec=stdio#sprintfsize">12.21</a>.)
</p><p>Here is
a contrived example
suggesting how you might
build a data file,
then sort it
(assuming the existence of a sort utility,
and Unix-
or MS-DOS-style
input/output redirection):
<pre>
	char *datafile = "file.dat";
	char *sortedfile = "file.sort";
	char cmdbuf[50];
	FILE *fp = fopen(datafile, "w");

	/* ...write to fp to build data file... */

	fclose(fp);

	sprintf(cmdbuf, "sort &lt; %s &gt; %s", datafile, sortedfile);
	system(cmdbuf);

	fp = fopen(sortedfile, "r");
	/* ...now read sorted data from fp... */
</pre>
</p><p>See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=stdio#constrpath">12.28b</a>.
<hr><hr><hr>
<a name="systemret">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/systemret.html"><!-- qtag -->Question 19.29</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How do I get an accurate error status return from <TT>system</TT> on MS-DOS?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
You can't;
COMMAND.COM

doesn't

tend to
provide one.
If you don't need
COMMAND.COM's

services
(i.e. if you're just trying to invoke a simple program,
without I/O redirection
and such)
try
one of the <TT>spawn</TT> routines, instead.
<hr><hr><hr>
<a name="popen">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/popen.html"><!-- qtag -->Question 19.30</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I invoke
another program
or command
and
trap
its output?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Unix
and some other systems provide a <TT>popen</TT>
function,
which sets up
a stdio stream
on a pipe
connected to the process
running a command,
so that the
calling program can read the output
(or
alternatively
supply the input).
Using <TT>popen</TT>,
the last example from
question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#system2">19.28</a>
would look like
<pre>
	extern FILE *popen();

	sprintf(cmdbuf, "sort &lt; %s", datafile);

	fp = popen(cmdbuf, "r");

	/* ...now read sorted data from fp... */

	pclose(fp);
</pre>

(Do be sure
to call <TT>pclose</TT>,
as shown;
leaving it out will seem to work at first
but may eventually run you out of processes




or
file descriptors.)
</p><p>If you can't use <TT>popen</TT>,
you may be able to use <TT>system</TT>,
with the output going to a file
which you then open and read,
as the code in question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#system2">19.28</a> was doing already.
<a href="concur.html" rel=subdocument>[footnote]</a>
</p><p>If you're using Unix and <TT>popen</TT> isn't sufficient,
you can learn about
<TT>pipe</TT>,
<TT>dup</TT>, 
<TT>fork</TT>,
and
<TT>exec</TT>.
</p><p>(One thing that
probably would <em>not</em> work,
by the way,
would be
to use <TT>freopen</TT>.)


</p>


<p>References:

PCS Sec. 11 p. 169
<hr><hr><hr>
<a name="exepath">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/exepath.html"><!-- qtag -->Question 19.31</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can my program discover the complete pathname to the executable
from
which it was invoked?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
<TT>argv[0]</TT> may contain all or part of the
pathname,
or it may contain nothing.
You may
be able to duplicate the command language interpreter's
search path logic to locate the
executable if the name in <TT>argv[0]</TT>
is
present but
incomplete.
However, there is no guaranteed
solution.
</p>



<p>References:

K&amp;R1 Sec. 5.11 p. 111
<br>
K&amp;R2 Sec. 5.10 p. 115
<br>
ISO Sec. 5.1.2.2.1
<br>
H&amp;S Sec. 20.1 p. 416
<hr><hr><hr>
<a name="auxfiles">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/auxfiles.html"><!-- qtag -->Question 19.32</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I automatically locate
a program's
configuration files
in the same directory as
the
executable?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
It's hard,
in general;

it's an equivalent problem to the one in
question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#exepath">19.31</a>.

Even if you can
figure out a workable way to do it,
you might want to consider making the program's
auxiliary (library) directory configurable,
perhaps with an environment variable.
(It's especially important to allow variable placement
of a program's configuration files
when the program will be used by several people,
e.g. on a multiuser system.)
<hr><hr><hr>
<a name="setenv">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/setenv.html"><!-- qtag -->Question 19.33</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can a process change an environment variable in its caller?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
It may or may not be possible to do so at all.
Different operating systems implement
global
name/value functionality
similar to the
Unix
environment
in different ways.
Whether the ``environment'' can be usefully altered by a
running program, and if so, how, is system-dependent.
</p><p>Under
Unix,
a process can modify its own environment
(some systems provide <TT>setenv</TT>
or <TT>putenv</TT> functions
for the purpose),
and the
modified environment is
generally
passed on to
child processes,
but it is
<em>not</em>
propagated back to the parent process.
(The environment of the parent process can only be altered if the
parent is explicitly set up
to listen for some kind of change requests.
The conventional execution of the BSD ``tset'' program in .profile
and .login files effects such a scheme.)
Under MS-DOS, it's possible to
manipulate the
master copy of the environment,

but the required techniques are arcane.
(See an MS-DOS FAQ list.)

<hr><hr><hr>
<a name="argv">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/argv.html"><!-- qtag -->Question 19.34</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I open files mentioned on the command line,
and parse option flags?
</p>
<p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#argv">20.3</a>.
<hr><hr><hr>
<a name="exitvsreturn">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/exitvsreturn.html"><!-- qtag -->Question 19.35</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Is <TT>exit(status)</TT> truly equivalent
to returning the same <TT>status</TT> from <TT>main</TT>?
</p>
<p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=ansi#exitvsreturn">11.16</a>.
<hr><hr><hr>
<a name="dynlink">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/dynlink.html"><!-- qtag -->Question 19.36</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I read in an object file and jump to
locations
in it?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
You want a dynamic linker or loader.
It may be possible to <TT>malloc</TT> some space
and read in object files,
but you have to know an awful lot
about object file formats, relocation, etc.,



and this approach can't work if code and data
reside in separate address spaces
or
if code is otherwise privileged.
</p><p>
Under BSD
Unix,
you could use <TT>system</TT> and <TT>ld&nbsp;-A</TT>
to do the linking for you.


Many

versions of SunOS and System V
have the -ldl library
containing routines like
<TT>dlopen</TT> and
<TT>dlsym</TT>
which
allow
object files to be dynamically
loaded.



Under VMS, use LIB$FIND_IMAGE_SYMBOL.
GNU
has
a
package called ``dld''.
See also question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=varargs#invvarargs">15.13</a>.
<hr><hr><hr>
<a name="subsecond">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/subsecond.html"><!-- qtag -->Question 19.37</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I implement a delay,
or time a user's response,
with sub-second resolution?

</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Unfortunately, there is no portable way.
Routines
you might look for on your system include
<TT>clock</TT>,



<TT>delay</TT>,
<TT>ftime</TT>,
<TT>gettimeofday</TT>,
<TT>msleep</TT>,
<TT>nap</TT>,



<TT>napms</TT>,




<TT>nanosleep</TT>,
<TT>setitimer</TT>,
<TT>sleep</TT>,




<TT>Sleep</TT>,
<TT>times</TT>,
and
<TT>usleep</TT>.
(A function called <TT>wait</TT>,
however,
is at least under Unix <em>not</em> what you want.)
The <TT>select</TT> and <TT>poll</TT> calls
(if available)
can be pressed into
service to implement simple delays.
On MS-DOS machines, it is possible to reprogram the system timer
and timer interrupts.

</p><p>Of these,
only
<TT>clock</TT> is part of the ANSI Standard.
The difference between two calls to <TT>clock</TT>

gives elapsed



execution
time,
and
may even
have subsecond resolution,
if CLOCKS_PER_SEC
is greater than 1.
However, <TT>clock</TT> gives
elapsed
processor time
used by the current program,
which
on a multitasking system
(or in a non-CPU-intensive program)
may
differ considerably from
real time.
</p><p>If you're trying to implement a delay
and all you have available
is a time-reporting function,
you can implement a
CPU-intensive
busy-wait,
but this is only
an
option on a single-user, single-tasking machine,
as it is terribly antisocial
to any other processes.
Under a multitasking operating system,
be sure to use
a
call
which puts your process to sleep for the duration,
such as <TT>sleep</TT> or <TT>select</TT>,
or <TT>pause</TT>
in conjunction with <TT>alarm</TT> or <TT>setitimer</TT>.
</p><p>For really brief delays,
it's tempting to use a do-nothing loop like
<pre>
	long int i;
	for(i = 0; i &lt; 1000000; i++)
		;
</pre>
but resist this temptation if at all possible!
For one thing,
your carefully-calculated delay loops
will
stop working
properly
next month when a faster processor comes out.
Perhaps
worse,

a
clever
compiler may notice that the loop does nothing
and optimize it away completely.
</p><p>Additional links:
A
<a href="sd25.html" rel=subdocument>technique involving I/O instructions</a>
described by Pedro Zorzenon Neto
</p>


<p>References:

H&amp;S Sec. 18.1 pp. 398-9
<br>
PCS Sec. 12 pp. 197-8,215-6
<br>
POSIX Sec. 4.5.2
<hr><hr><hr>
<a name="sigint">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/sigint.html"><!-- qtag -->Question 19.38</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I trap or ignore
keyboard interrupts
like
control-C?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
The basic step is to call <TT>signal</TT>,
either as
<pre>
	#include &lt;signal.h&gt;
	signal(SIGINT, SIG_IGN);
</pre>
to ignore
the interrupt signal,
or as
<pre>
	extern void func(int);
	signal(SIGINT, func);
</pre>
to cause control to transfer to function <TT>func</TT>
on receipt of
an interrupt signal.
<a href="keybintr.html" rel=subdocument>[footnote]</a>
</p><p>On a multi-tasking system such as Unix,
it's best to use a slightly more
involved
technique:
<pre>
	extern void func(int);
	if(signal(SIGINT, SIG_IGN) != SIG_IGN)
		signal(SIGINT, func);
</pre>
The test and extra call

ensure that a
keyboard interrupt
typed in the foreground won't 
inadvertently interrupt a program running in the background
(and it doesn't hurt to code calls to <TT>signal</TT> this way 
on any system).
<a href="pgrps.html" rel=subdocument>[footnote]</a>
</p><p>On some systems,
keyboard interrupt
handling is also a function of
the mode of
the terminal-input subsystem;
see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#cbreak">19.1</a>.
On some
systems,

checking for
keyboard interrupts
is only performed when the program is 
reading input,
and
keyboard interrupt
handling may therefore depend on which input 
routines are being called
(and <em>whether</em> any input routines are active at all).

On MS-DOS systems, <TT>setcbrk</TT>
or <TT>ctrlbrk</TT>

functions
may also be involved.
</p>



<p>References:

ISO Secs. 7.7,7.7.1
<br>
H&amp;S Sec. 19.6 pp. 411-3
<br>
PCS Sec. 12 pp. 210-2
<br>
POSIX Secs. 3.3.1,3.3.4
<hr><hr><hr>
<a name="fpexcepts">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/fpexcepts.html"><!-- qtag -->Question 19.39</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I
handle
floating-point exceptions gracefully?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
On many systems, you can define a function <TT>matherr</TT>
which will be called when there are certain floating-point errors,
such as errors in the math routines in <TT>&lt;math.h&gt;</TT>.
You may also be able to use <TT>signal</TT>
(see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#sigint">19.38</a>)
to catch SIGFPE.
See also
questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=fp#nan">14.9</a> and <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#intovf">20.6b</a>.
</p>
<p>References:

Rationale Sec. 4.5.1
<hr><hr><hr>
<a name="intovf2">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/intovf2.html"><!-- qtag -->Question 19.39b</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I ensure that integer arithmetic doesn't overflow?
</p>
<p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#intovf">20.6b</a>.
<hr><hr><hr>
<a name="networking">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/networking.html"><!-- qtag -->Question 19.40</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How do I...
Use sockets?
Do networking?
Write client/server applications?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
All of
these
questions
are outside of the scope of this
list
and
have
much
more to do with
the networking facilities
which
you have available
than they do with C.
Good books on the subject are
Douglas Comer's three-volume
<I>Internetworking with TCP/IP</I>
and 
W. R. Stevens's
<I>UNIX Network Programming</I>.
There is also plenty of information out on the net itself,
including the
``<a href="http://www.developerweb.net/sock-faq/">Unix Socket FAQ</a>'',
and




<a href="http://www.ecst.csuchico.edu/~beej/guide/net/">"Beej's Guide to Network Programming"</a>.
</p><p>(One tip:
depending on your OS,
you may need to explicitly request
the <TT>-lsocket</TT> and <TT>-lnsl</TT> libraries;
see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=lib#extlibs">13.25</a>.)
<hr><hr><hr>
<a name="xobjfiles">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/xobjfiles.html"><!-- qtag -->Question 19.40a</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Can I combine .OBJ and .LIB files from Microsoft C and Turbo C?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Not easily;
see the comp.os.msdos.programmer FAQ list.
<hr><hr><hr>
<a name="tsr">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/tsr.html"><!-- qtag -->Question 19.40b</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How do I...
Use BIOS calls?
Write
ISR's?
Create TSR's?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
These are very particular to
specific systems
(PC compatibles running MS-DOS, most likely).
You'll get much better information in a specific newsgroup
such as comp.os.msdos.programmer
or its FAQ list;

another excellent resource is Ralf Brown's interrupt list.
<hr><hr><hr>
<a name="int86">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/int86.html"><!-- qtag -->Question 19.40c</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
I'm trying to compile
this program,
but the compiler is complaining that
``<TT>union&nbsp;REGS</TT>''
is undefined,
and the linker
is complaining that
<TT>int86</TT>
is
undefined.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Those have to do with MS-DOS interrupt programming.
They don't exist on other systems.
<hr><hr><hr>
<a name="nearfar">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/nearfar.html"><!-- qtag -->Question 19.40d</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What are ``near'' and ``far'' pointers?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
These days, they're pretty much obsolete;
they're definitely system-specific.
They had to do with 16-bit programming under MS-DOS and perhaps
some early versions of Windows.
If you really need to know, see a DOS- or Windows-specific
programming reference.
If you're using a machine which doesn't require
(or permit)
making the near/far pointer distinction,
just delete the unnecessary ``near'' and ``far'' keywords
(perhaps using the preprocessor:
``<TT>#define far /* nothing */</TT>'').
<hr><hr><hr>
<a name="gottabe">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/gottabe.html"><!-- qtag -->Question 19.41</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
But I can't use all these nonstandard, system-dependent functions,
because my program has to be ANSI compatible!
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
You're out of luck.
Either you misunderstood your requirement,
or it's an impossible one to meet.
ANSI/ISO Standard C simply does not define ways of doing these things;
it is a language standard, not an operating system standard.
An international standard
which does address many of these issues
is POSIX (IEEE&nbsp;1003.1, ISO/IEC&nbsp;9945-1),
and many operating systems
(not just Unix)
now have POSIX-compatible programming interfaces.


</p><p>It is possible,
and desirable,
for <em>most</em> of a program to be ANSI-compatible,
deferring the system-dependent functionality
to a few routines 
in a few files
which
are
either heavily #ifdeffed
or
rewritten entirely
for each system ported to;
see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#cbreak">19.1</a> for an example.
See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#sysdep">19.42</a>.
<hr><hr><hr>
<a name="sysdep">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../osdep/sysdep.html"><!-- qtag -->Question 19.42</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Why
isn't any of this
standardized in C?
Any real program has to do some of these things.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Actually,
some standardization has occurred along the way.
In the beginning,
C did not have a standard library at all;
programmers always had to ``roll their own'' utility
routines.
After several abortive attempts,
a
certain
set
of library routines
(including the <TT>str*</TT>

and stdio families of routines)
became a <I>de facto</I> standard,
at least on Unix systems,
but the library was not
yet
a formal part of the language.
Vendors could
(and occasionally did)
provide completely different routines along with their compilers.
</p><p>In ANSI/ISO Standard C,
a library definition
(based on
the 1984 /usr/group standard,
and
largely compatible with
the traditional Unix library)
was adopted with as much standing as the language itself.
The Standard C library's treatment of file and device I/O is,
however,
rather
minimal.
It states how streams of characters are written to and read 
from files,
and it provides a few suggestions
about the
display
behavior of
control characters like <TT>\b</TT>, <TT>\r</TT>, and <TT>\t</TT>,
but beyond that it is silent.
(Many of these issues are, however,
addressed and standardized in Posix.)
</p><p>If the Standard were
to
attempt to define standard mechanisms for accessing
things like
keyboards and displays,
it
might seem to be a big convenience for programmers.

But it would be a monumental
task:
there is already a huge variety of display devices,
and huge variation among the operating systems through which 
they
are usually accessed.
We cannot assume that the years to come will offer any less 
variety.
</p><p>At one time the common output device for C programs was a Teletype;

later it was a
``dumb'' terminal,
after that it was a ``smart'' VT100 or other 
ANSI&nbsp;X3.64-compatible terminal
which today might be called ``dumb.''
Today

it's likely to be a bitmapped color display screen.
What will it be in five years?
How will the operating systems of that time deal with its capabilities?
</p><p>See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=ansi#appalled">11.34</a>.
</p>


<p>References:

Rationale Sec. 2.2.2, Sec. 4.9, Sec. 4.9.2
<hr><hr><hr>
<hr>
<p>
Read sequentially:
<a href="/~scs/cgi-bin/faqcat.cgi?sec=resources" rev=precedes>prev</a>
<a href="/~scs/cgi-bin/faqcat.cgi?sec=misc" rel=precedes>next</a>
<a href="/~scs/cgi-bin/faqcat.cgi" rev=subdocument>up</a>
</p>
<hr>
<p>
<br><!-- lastfooter -->
<a href="../about.html">about this FAQ list</a>
&nbsp;
<a href="../eskimo.html">about eskimo</a>
&nbsp;
<a href="../search.html">search</a>
&nbsp;
<a href="../feedback.html">feedback</a>
&nbsp;
<a href="copyright.html">copyright</a>
<p>
Hosted by
<a href="http://www.eskimo.com/"><img src="http://www.eskimo.com/img/link/eskitiny.gif" alt="Eskimo North"></a>
</body>
</html>
