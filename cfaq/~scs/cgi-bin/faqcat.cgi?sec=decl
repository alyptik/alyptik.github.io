<!DOCTYPE HTML PUBLIC "-//W3O//DTD W3 HTML 2.0//EN">
<!-- This collection of hypertext pages is Copyright 1995-2005 by Steve Summit. -->
<!-- Content from the book "C Programming FAQs: Frequently Asked Questions" -->
<!-- (Addison-Wesley, 1995, ISBN 0-201-84519-9) is made available here by -->
<!-- permission of the author and the publisher as a service to the community. -->
<!-- It is intended to complement the use of the published text -->
<!-- and is protected by international copyright laws. -->
<!-- The on-line content may be accessed freely for personal use -->
<!-- but may not be published or retransmitted without explicit permission. -->
<!-- -->
<!-- this page built Sat Dec 24 21:47:45 2005 by faqproc version 2.7 -->
<!-- from source file decl.sgml dated Wed Dec 21 12:56:18 2005 -->
<!-- corresponding to FAQ list version 4.0 -->
<html>
<head>
<base href="http://c-faq.com/decl/index.html">
<meta name=GENERATOR content="faqproc">
<title>Declarations and Initializations</title>
</head>
<body bgcolor="#ffffff">
<H1>1. Declarations and Initializations</H1>
<a name="inttypes">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/inttypes.html"><!-- qtag -->Question 1.1</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>

How should I decide which integer type to use?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
If you might need large values
(above 32,767 or below -32,767),
use <TT>long</TT>.
Otherwise,
if
space is very important
(i.e. if
there are large arrays or many structures),
use <TT>short</TT>.
Otherwise,

use <TT>int</TT>.
If well-defined overflow characteristics are important

and
negative values are not,
or if you want to
steer clear of

sign-extension problems when manipulating bits or bytes,
use
one of
the corresponding <TT>unsigned</TT> types.
(Beware
when
mixing signed and unsigned

values
in expressions,
though;
see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=expr#preservingrules">3.19</a>.)
</p><p>Although
character types
(especially <TT>unsigned&nbsp;char</TT>)
can

be used as
``tiny''
integers,
doing so is
sometimes
more trouble than it's worth.
The compiler will have to emit extra code
to convert between <TT>char</TT> and <TT>int</TT>
(making the executable larger),
and
unexpected sign extension can
be troublesome.
(Using <TT>unsigned&nbsp;char</TT> can help;
see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=stdio#getcharc">12.1</a> for a related problem.)
</p><p>A similar space/time tradeoff applies
when deciding between <TT>float</TT>
and <TT>double</TT>.
(Many compilers still convert all <TT>float</TT> values to 
<TT>double</TT>
during expression evaluation.)

None of the above rules
apply


if
pointers to the variable
must have a particular type.


</p><p>Variables referring to certain kinds of data,
such as sizes of objects in memory,
can and should use predefined abstract types
such as <TT>size_t</TT>.

</p><p>It's often
incorrectly
assumed that C's types are defined to have certain, exact sizes.
In fact,
what's guaranteed is that:
<UL><li>type <TT>char</TT> can hold values up to 127;
<li>types <TT>short int</TT> and <TT>int</TT> can hold values up to 32,767;
and
<li>type <TT>long int</TT> can hold values up to 2,147,483,647.

<li>something like
the relation
<pre>
	sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)
</pre>
holds.
<a href="fn1.html" rel=subdocument>[footnote]</a>
</UL></p><p>From these values, it can be inferred that <TT>char</TT> is at 
least 8 bits,
<TT>short int</TT> and <TT>int</TT> are at least 16 bits,
and <TT>long int</TT> is at least 32 bits.
(The signed and unsigned versions of each type
are guaranteed to have the same size.)
Under ANSI C,
the maximum and minimum values 
for a particular machine
can be found in the header file <TT>&lt;limits.h&gt;</TT>;
here is a summary:
<table><tr><td>Base type</td><td>Minimum size (bits)</td><td>Minimum value (signed)</td><td>Maximum value (signed)</td><td>Maximum value (unsigned)</td></tr>
<tr><td><TT>char</TT></td><td>8</td><td>-127</td><td>127</td><td>255</td></tr>
<tr><td><TT>short</TT></td><td>16</td><td>-32,767</td><td>32,767</td><td>65,535</td></tr>
<tr><td><TT>int</TT></td><td>16</td><td>-32,767</td><td>32,767</td><td>65,535</td></tr>
<tr><td><TT>long</TT></td><td>32</td><td>-2,147,483,647</td><td>2,147,483,647</td><td>4,294,967,295</td></tr>
</table>(These values are the minimums guaranteed by the Standard.
Many implementations allow larger values,
but portable programs shouldn't depend on it.)
</p><p>If for some reason you need to declare something with an
exact
size
(usually the only good reason for doing so
is when attempting to conform
to some externally-imposed storage layout,
but see question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#binaryfiles">20.5</a>),
be sure to encapsulate the choice
behind an appropriate typedef,
but see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#int16">1.3</a>.
</p><p>If you need to manipulate huge values,
larger than the guaranteed range of C's built-in types,
you need an arbitrary-precision
(or ``multiple precision'')
arithmetic library;
see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=resources#mplib">18.15d</a>.
</p>






<p>References:

K&amp;R1 Sec. 2.2 p. 34
<br>
K&amp;R2 Sec. 2.2 p. 36, Sec. A4.2 pp. 195-6, Sec. B11 p. 257
<br>
ISO Sec. 5.2.4.2.1, Sec. 6.1.2.5
<br>
H&amp;S Secs. 5.1,5.2 pp. 110-114
<hr><hr><hr>
<a name="exactsizes">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/exactsizes.html"><!-- qtag -->Question 1.2</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Why aren't the sizes of the standard types precisely defined?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Though C is considered relatively low-level
as high-level languages go,
it does take the position
that the exact size of
an object
(i.e. in bits)
is an implementation detail.
(The only place where C lets you specify a size in bits
is in bit-fields within structures;
see questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=struct#bitfield0">2.25</a> and <a href="/~scs/cgi-bin/faqcat.cgi?sec=struct#bitfields">2.26</a>.)
Most programs
do not need precise control
over
these sizes;
many programs that do
try to achieve this control
would be better off if they didn't.
</p><p>Type
<TT>int</TT> is supposed to represent a machine's natural word size.
It's the right type to use for most integer variables;
see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#inttypes">1.1</a> for other guidelines.
See also questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=stdio#extconform">12.42</a>
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#binaryfiles">20.5</a>.
<hr><hr><hr>
<a name="int16">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/int16.html"><!-- qtag -->Question 1.3</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Since C doesn't define sizes exactly,
I've been using
typedefs
like <TT>int16</TT> and
<TT>int32</TT>.
I can then define these typedefs
to be <TT>int</TT>, <TT>short</TT>, <TT>long</TT>,
etc. depending on what machine I'm using.

That should solve everything, right?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
If you truly need
control
over exact type sizes,
this is the right approach.
There remain several things to be aware of:
<UL><li>There might not be an exact match on some machines.
(There are, for example, 36-bit machines.)

<li>A typedef like <TT>int16</TT> or <TT>int32</TT>
accomplishes nothing
if its intended meaning is ``at least'' the specified size,
because types <TT>int</TT> and <TT>long</TT>
are <em>already</em> essentially defined as being
``at least 16 bits'' and
``at least 32 bits,'' respectively.
<li>Typedefs
will never
do anything about byte order problems
(e.g.
if you're trying to interchange data
or conform to
externally-imposed storage layouts).
<li>You no longer have to define your own typedefs,
because the Standard header <TT>&lt;inttypes.h&gt;</TT>
contains a complete set.
</UL></p><p>See also questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=cpp#ifendian">10.16</a>
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#binaryfiles">20.5</a>.
<hr><hr><hr>
<a name="octabyte">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/octabyte.html"><!-- qtag -->Question 1.4</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What should the 64-bit type be
on a
machine that can support it?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
The
new
C99 Standard
specifies type <TT>long&nbsp;long</TT> as effectively being
at least 64 bits,
and this type has been implemented by a number of compilers
for some time.
(Others have implemented extensions such as <TT>__longlong</TT>.)
On the other hand,
it's also appropriate to
implement
type <TT>short&nbsp;int</TT> as 16,
<TT>int</TT> as 32,
and <TT>long&nbsp;int</TT> as 64 bits,
and some compilers do.
</p><p>See also
questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#int16">1.3</a> and <a href="/~scs/cgi-bin/faqcat.cgi?sec=resources#mplib">18.15d</a>.
</p><p>Additional links:




Part of a

<a href="longlong.awjd.html">proposal for <TT>long&nbsp;long</TT> for C9X</a>
by Alan Watson and Jutta Degener,
succinctly outlining the arguments.
</p>

<p>References:

C9X Sec. 5.2.4.2.1, Sec. 6.1.2.5
<hr><hr><hr>
<a name="charstarws">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/charstarws.html"><!-- qtag -->Question 1.5</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What's wrong with
this
declaration?
<pre>
char* p1, p2;</pre>




I get errors when I try to
use
<TT>p2</TT>.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>



Nothing is wrong with the declaration--except
that it doesn't do what you probably want.
The <TT>*</TT> in a pointer declaration is not part of the base type;
it is part of the <a href="../sx1/index.html#declarator"><dfn>declarator</dfn></a>
containing the name being declared
(see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#cdecl1">1.21</a>).
That is,


in C, the syntax and interpretation of a declaration is not really
<pre>
	<I>type identifier</I> ;
</pre>
but rather
<pre>
	<I>base_type thing_that_gives_base_type</I> ;
</pre>
where ``<I>thing_that_gives_base_type</I>''--the
<a href="../sx1/index.html#declarator"><dfn>declarator</dfn></a>--is
either a simple identifier,
or a notation like <TT>*p</TT> or <TT>a[10]</TT> or <TT>f()</TT>
indicating that the variable being declared is a pointer to,
array of, or function returning that <I>base_type</I>.
(Of course, more complicated declarators are possible as well.)
</p><p>In the declaration
as written in the question,
no matter what the whitespace
suggests,
the base type is <TT>char</TT> and
the first declarator is ``<TT>*&nbsp;p1</TT>'',
and since the declarator contains a <TT>*</TT>,
it declares <TT>p1</TT> as a pointer-to-<TT>char</TT>.
The declarator for <TT>p2</TT>, however,
contains nothing but <TT>p2</TT>,
so <TT>p2</TT> is declared as a plain <TT>char</TT>,
probably not what was intended.
To declare two pointers within the same declaration,
use
<pre>
	char *p1, *p2;
</pre>
Since the <TT>*</TT> is part of the declarator,
it's best to use whitespace as shown;
writing <TT>char*</TT> invites mistakes and confusion.

</p><p>See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#typedefvsdefine">1.13</a>.
</p><p>Additional links:
<a href="http://www.research.att.com/~bs/bs_faq2.html#whitespace">Bjarne Stroustrup's opinion</a>
<hr><hr><hr>
<a name="mimic">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/mimic.html"><!-- qtag -->Question 1.6</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
I'm trying to declare a pointer and allocate some space for it,
but it's
not working.
What's wrong with
this code?
<pre>
char *p;
*p = malloc(10);</pre>

</p>
<p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
The pointer you declared is <TT>p</TT>,
not <TT>*p</TT>.
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=ptrs#mimic">4.2</a>.
<hr><hr><hr>
<a name="decldef">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/decldef.html"><!-- qtag -->Question 1.7</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What's the best way to declare and define
global variables
and functions?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
First, though there can be many
<a href="../sx1/index.html#declarations"><dfn>declarations</dfn></a>
(and in many translation units)
of a single
global
variable
or function,
there must be exactly one
<a href="../sx1/index.html#definition"><dfn>definition</dfn></a>.
<a href="unused.html" rel=subdocument>[footnote]</a>
For global variables,
the
definition is the declaration that actually allocates space,
and provides an initialization value, if any.
For functions,
the definition is
the ``declaration''

that provides the function body.
For example,

these are declarations:
<pre>
	extern int i;

	extern int f();
</pre>
and these are definitions:
<pre>
	int i = 0;

	int f()
	{
		return 1;
	}
</pre>
(Actually, the keyword <TT>extern</TT> is optional in function 
declarations;
see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#extern">1.11</a>.)
</p><p>When you need to share variables or functions
across several
source files,
you will of course want to ensure
that all definitions and declarations are consistent.
The best arrangement
is to
place each
definition in some relevant
.c file.
Then,
put
an external declaration in a
header
(``<TT>.h</TT>'')
file,
and <TT>#include</TT> it
wherever the declaration is needed.
The <TT>.c</TT> file containing the definition should also <TT>#include</TT> the
same header file,
so the compiler can check
that the definition matches the declarations.
</p><p>This rule promotes a high degree of portability:

it
is consistent with the requirements of the ANSI C Standard,
and is also consistent with most pre-ANSI compilers and linkers.
(Unix
compilers and linkers typically use a ``common model''
which allows multiple definitions,
as long as at most one is initialized;
this
behavior is mentioned as a ``common extension'' by
the ANSI Standard,
no
<a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#common">pun</a>
intended.
A few
very old
systems
might once have required
an explicit initializer to
distinguish a definition from an external declaration.)
</p><p>It is possible to use preprocessor tricks
to arrange that
a line like
<pre>
	DEFINE(int, i);
</pre>
need only be entered once in one header file,

and turned into a definition or a declaration
depending on the setting of some macro,
but it's not clear if
this is
worth the trouble,
especially since it's usually a
better
idea
to keep global variables to a minimum.
</p><p>It's
not just a good idea
to put global declarations in header files:
if you want the compiler
to
be able to
catch inconsistent declarations for you,
you <em>must</em> place them in header files.
In particular,
never place a prototype for an external function
in a .c file--if
the definition of the function ever changes,
it would be too easy to forget to change the prototype,
and an incompatible
prototype is worse than useless.
</p><p>See also
questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#extarraysize">1.24</a>, <a href="/~scs/cgi-bin/faqcat.cgi?sec=cpp#hfiles">10.6</a>, <a href="/~scs/cgi-bin/faqcat.cgi?sec=style#srcfiles">17.2</a>, and <a href="/~scs/cgi-bin/faqcat.cgi?sec=resources#lintvsansi">18.8</a>.

</p>










<p>References:

K&amp;R1 Sec. 4.5 pp. 76-7
<br>
K&amp;R2 Sec. 4.4 pp. 80-1
<br>
ISO Sec. 6.1.2.2, Sec. 6.7, Sec. 6.7.2, Sec. G.5.11
<br>
Rationale Sec. 3.1.2.2
<br>
H&amp;S Sec. 4.8 pp. 101-104, Sec. 9.2.3 p. 267
<br>
CT&amp;P Sec. 4.2 pp. 54-56
<hr><hr><hr>
<a name="opaque">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/opaque.html"><!-- qtag -->Question 1.8</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I implement
opaque (abstract) data types in C?
</p>
<p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=struct#opaquetypes">2.4</a>.
<hr><hr><hr>
<a name="semiglobal">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/semiglobal.html"><!-- qtag -->Question 1.9</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I make a sort of ``semi-global'' variable,
that is,
one that's
private to a few functions spread across a few source files?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
You can't do this in C.
If it's impossible or inconvenient to put all the functions in 
the same source file,
there are two usual solutions:
<OL><li>Pick a unique prefix
for the names
of all functions and global variables 
in a
library or package of related routines,
and warn users of the package

not to define
or use
any symbols with names matching that prefix

other than those documented as 
being for public consumption.

(In other words, an undocumented but otherwise global symbol
with a name matching that prefix
is, by convention, ``private.'')
<li>Use a name beginning with an underscore,
since such names shouldn't be used by ordinary code.
(See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#namespace">1.29</a> for more information,
and
for

a description of the ``no man's land''
between the user and implementation namespaces.)
</OL></p><p>It may also be possible to use special linker
invocations
to adjust the visibility of names,
but any such
techniques
are outside of the scope of the C language.
<hr><hr><hr>
<a name="static">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/static.html"><!-- qtag -->Question 1.10</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Do
all
declarations for
the same
<TT>static</TT> function
or variable
have to include the storage class <TT>static</TT>?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
The language in the Standard does not quite require this

(what's most important
is that the <em>first</em> declaration
contain


<TT>static</TT>),
but the rules are
rather intricate,

and
are
slightly different for functions
than
for data
objects.
(There has also been
a lot of historical variation
in this area.)
Therefore,
it's
safest if
<TT>static</TT> appears consistently
in the definition and all declarations.
</p><p>Additional links:




An <a href="static.jd.html">article by Jutta Degener</a>
explaining the subtly different rules
for static variables versus static functions.
</p>





<p>References:

ISO Sec. 6.1.2.2
<br>
Rationale Sec. 3.1.2.2
<br>
H&amp;S Sec. 4.3 p. 75
<hr><hr><hr>
<a name="extern">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/extern.html"><!-- qtag -->Question 1.11</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What does <TT>extern</TT> mean in a function declaration?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
<TT>extern</TT> is


significant
only
with data declarations.
In function declarations,
it
can be used as a stylistic hint
to indicate that the function's definition
is probably in another source file,
but there is no formal
difference
between
<pre>
	extern int f();
</pre>
and
<pre>
	int f();
</pre>
</p><p>See also question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#static">1.10</a>.
</p>




<p>References:

ISO Sec. 6.1.2.2, Sec. 6.5.1
<br>
Rationale Sec. 3.1.2.2
<br>
H&amp;S Secs. 4.3,4.3.1 pp. 75-6
<hr><hr><hr>
<a name="auto">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/auto.html"><!-- qtag -->Question 1.12</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What's the <TT>auto</TT> keyword good for?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Nothing;
it's archaic.
<a href="fn3.html" rel=subdocument>[footnote]</a>
(It's a holdover from
C's
typeless
predecessor language B,

where in the absence of



keywords like <TT>int</TT>
a declaration always needed a storage class.)
See also question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#entry">20.37</a>.
</p>




<p>References:

K&amp;R1 Sec. A8.1 p. 193
<br>
ISO Sec. 6.1.2.4, Sec. 6.5.1
<br>
H&amp;S Sec. 4.3 p. 75, Sec. 4.3.1 p. 76
<hr><hr><hr>
<a name="typedefvsdefine">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/typedefvsdefine.html"><!-- qtag -->Question 1.13</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What's the difference between using a <TT>typedef</TT>
or

a <TT>#define</TT>
for a user-defined type?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
In general, <TT>typedef</TT>s are preferred,
in part because they can correctly encode pointer types.
For example,
consider these declarations:

<pre>
	typedef char *String_t;
	#define String_d char *
	String_t s1, s2;
	String_d s3, s4;
</pre>
<TT>s1</TT>, <TT>s2</TT>, and <TT>s3</TT> are all declared as <TT>char&nbsp;*</TT>,
but
<TT>s4</TT> is declared as a <TT>char</TT>,
which is probably not the intention.
(See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#charstarws">1.5</a>.)
</p><p><TT>#define</TT>s do have the advantage that <TT>#ifdef</TT> works on them
(see also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=cpp#iftypedef">10.15</a>).
On the other hand,
<TT>typedef</TT>s

have the advantage that they obey scope rules
(that is, they can be declared local to a function or block).
</p><p>See also questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#pfitypedef">1.17</a>,
<a href="/~scs/cgi-bin/faqcat.cgi?sec=struct#enumvsdefine">2.22</a>,
<a href="/~scs/cgi-bin/faqcat.cgi?sec=ansi#typedefconst">11.11</a>,
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=varargs#funcptr">15.11</a>.
</p>


<p>References:

K&amp;R1 Sec. 6.9 p. 141
<br>
K&amp;R2 Sec. 6.7 pp. 146-7
<br>
CT&amp;P Sec. 6.4 pp. 83-4
<hr><hr><hr>
<a name="selfrefstruct">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/selfrefstruct.html"><!-- qtag -->Question 1.14</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>

I can't seem to define a linked list
successfully.
I tried
<pre>
	typedef struct {
		char *item;
		NODEPTR next;
	} *NODEPTR;
</pre>
but the compiler gave me error messages.
Can't a structure in C contain a pointer to itself?

</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Structures in C can certainly contain pointers to themselves; the
discussion and example in section 6.5 of K&amp;R

make this clear.
</p><p>The problem with
this example is



the typedef.


A typedef defines a new name for a type,
and in simpler cases
<a href="immtypedef.html" rel=subdocument>[footnote]</a>
you can define a new structure type
and a typedef for it
at the same time,
but not in this case.
A typedef declaration can
not be used until it is defined,
and in the fragment above,
it is not yet
defined
at the point where
the <TT>next</TT> field is declared.
</p><p>To fix
this code,
first
give the structure a tag (e.g. ``<TT>struct&nbsp;node</TT>'').
Then,
declare the <TT>next</TT> field
as
a simple
<TT>struct&nbsp;node&nbsp;*</TT>,

or disentangle the typedef declaration from the structure definition,
or both.
One
corrected
version would be:
<pre>
	typedef struct node {
		char *item;
		struct node *next;
	} *NODEPTR;
</pre>
You could also precede the struct declaration

with
the typedef,
in which case you could use the <TT>NODEPTR</TT> typedef when declaring
the <TT>next</TT> field,
after all:
<pre>
	typedef struct node *NODEPTR;

	struct node {
		char *item;
		NODEPTR next;
	};
</pre>
(In this case,
you declare a new tyedef name involving <TT>struct&nbsp;node</TT>
even though <TT>struct&nbsp;node</TT>
has not been
completely
defined
yet;

this you're allowed to do.<a href="jst1.html" rel=subdocument>[footnote]</a>
)
</p><p>Finally,
here is a rearrangement incorporating both suggestions:
<pre>
	struct node {
		char *item;
		struct node *next;
	};

	typedef struct node *NODEPTR;
</pre>
</p><p>(It's a matter of style which method to prefer;
see
section
<a href="/~scs/cgi-bin/faqcat.cgi?sec=style#index">17</a>.)
</p><p>See also questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#mutrefstructs">1.15</a>
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=struct#typedef">2.1</a>.
</p>







<p>References:

K&amp;R1 Sec. 6.5 p. 101
<br>
K&amp;R2 Sec. 6.5 p. 139
<br>
ISO Sec. 6.5.2, Sec. 6.5.2.3
<br>
H&amp;S Sec. 5.6.1 pp. 132-3
<hr><hr><hr>
<a name="mutrefstructs">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/mutrefstructs.html"><!-- qtag -->Question 1.15</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I define a pair of mutually referential structures?
I tried
<pre>
	typedef struct {
		int afield;
		BPTR bpointer;
	} *APTR;

	typedef struct {
		int bfield;
		APTR apointer;
	} *BPTR;
</pre>
but the compiler doesn't know about
<TT>BPTR</TT>
when it is used in
the first structure declaration.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
As in question <a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#selfrefstruct">1.14</a>,
the problem lies not in
the structures or
the pointers but the typedefs.
First,
give the two structures tags,
and
define
the link pointers
without using typedefs:
<pre>
	struct a {
		int afield;
		struct b *bpointer;
	};

	struct b {
		int bfield;
		struct a *apointer;
	};
</pre>
The compiler can accept the field declaration <TT>struct&nbsp;b&nbsp;*bpointer</TT>
within <TT>struct&nbsp;a</TT>,
even though it has not yet heard of
<TT>struct&nbsp;b</TT>.
(<TT>struct&nbsp;b</TT> is
``incomplete''
at that point.)

Occasionally it is necessary to precede this couplet with the
empty declaration
<pre>
	struct b;
</pre>
to mask the declarations (if in an inner scope) from a different
<TT>struct&nbsp;b</TT> in an outer scope.
</p><p>After declaring the two structures using struct tags,
you can then declare the typedefs separately:
<pre>
	typedef struct a *APTR;
	typedef struct b *BPTR;
</pre>
</p><p>
Alternatively,

you can define the typedefs
before the struct definitions<a href="jst2.html" rel=subdocument>[footnote]</a>
,
in which case you can use them when declaring the link pointer 
fields:
<pre>
	typedef struct a *APTR;
	typedef struct b *BPTR;

	struct a {
		int afield;
		BPTR bpointer;
	};

	struct b {
		int bfield;
		APTR apointer;
	};
</pre>
</p><p>See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#selfrefstruct">1.14</a>.
</p>



<p>References:

K&amp;R2 Sec. 6.5 p. 140
<br>
ISO Sec. 6.5.2.3
<br>
H&amp;S Sec. 5.6.1 p. 132
<hr><hr><hr>
<a name="structtypdf">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/structtypdf.html"><!-- qtag -->Question 1.16</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What's the difference between
these two declarations?
<pre>
	struct x1 { ... };
	typedef struct { ... } x2;
</pre>
</p>
<p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=struct#typedef">2.1</a>.
<hr><hr><hr>
<a name="pfitypedef">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/pfitypedef.html"><!-- qtag -->Question 1.17</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What does
<pre>
typedef int (*funcptr)();</pre>

mean?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
It defines a typedef, <TT>funcptr</TT>, for a pointer to a
function
(taking unspecified arguments)
returning an <TT>int</TT>.
It can be used to
declare
one or more
pointers to functions:
<pre>
	funcptr pf1, pf2;
</pre>
which is equivalent to the more verbose,
and perhaps harder to understand
<pre>
	int (*pf1)(), (*pf2)();
</pre>
See also questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#cdecl1">1.21</a>,

<a href="/~scs/cgi-bin/faqcat.cgi?sec=ptrs#funccall">4.12</a>,
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=varargs#funcptr">15.11</a>.
</p>

<p>References:

K&amp;R1 Sec. 6.9 p. 141
<br>
K&amp;R2 Sec. 6.7 p. 147
<hr><hr><hr>
<a name="typdfcnst">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/typdfcnst.html"><!-- qtag -->Question 1.18</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
I've got
the declarations
<pre>
	typedef char *charp;
	const charp p;
</pre>
Why is <TT>p</TT> turning out <TT>const</TT>,
instead of the characters pointed to?
</p>
<p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=ansi#typedefconst">11.11</a>.
<hr><hr><hr>
<a name="constasconst">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/constasconst.html"><!-- qtag -->Question 1.19</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
I don't understand why I can't
use <TT>const</TT> values in initializers and array
dimensions,
as in
<pre>
	const int n = 5;
	int a[n];
</pre>
</p>
<p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=ansi#constasconst">11.8</a>.
<hr><hr><hr>
<a name="constptrconst">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/constptrconst.html"><!-- qtag -->Question 1.20</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What's the difference between
<TT>const&nbsp;char&nbsp;*p</TT>,
<TT>char&nbsp;const&nbsp;*p</TT>,
and <TT>char&nbsp;*&nbsp;const&nbsp;p</TT>?
</p>
<p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
See questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=ansi#constptrconst">11.9</a>
and

<a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#cdecl1">1.21</a>.
<hr><hr><hr>
<a name="constparm">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/constparm.html"><!-- qtag -->Question 1.20b</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What does it mean for a function parameter to be <TT>const</TT>?
What do the two <TT>const</TT>'s in
<pre>
	int f(const * const p)
</pre>
mean?
</p>



<p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
In
<pre>
	int f(const * const p)
</pre>
the first of the two <TT>const</TT>'s
is perfectly appropriate and quite useful; many
functions declare parameters which are pointers to const data,
and doing so documents (and tends to enforce) the function's
promise that it won't modify the pointed-to data in the caller.
The second <TT>const</TT>, on the other hand, is almost useless; all it
says is that the function won't alter its own copy of the
pointer, even though it wouldn't cause the caller <em>or</em> the
function any problems if it did, nor is this anything the caller
should care about in any case.
The situation is the same as if a
function declared an ordinary (non-pointer) parameter as const:
<pre>
	int f2(const int x)
</pre>
This says that nowhere in the body of <TT>f2()</TT> will the function
assign a different value to <TT>x</TT>.
(Compilers should try to enforce this promise, too.)
But assigning a
different value to <TT>x</TT> wouldn't affect the value that the caller
had passed (because C always uses call-by-value), so it's an
unimportant guarantee, and in fact a pretty useless one, because
what does the function gain by promising (to itself, since it's
the only one that could care) whether it will or won't be
modifying in the passed-in copy of the value?
<hr><hr><hr>
<a name="cdecl1">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/cdecl1.html"><!-- qtag -->Question 1.21</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How do I
construct
declarations of complicated types such as
``array of N pointers to functions returning
pointers to functions returning pointers
to <TT>char</TT>'',
or figure out what similarly complicated declarations mean?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
The first part of
this
question can be answered in
at least three ways:
<OL><li><TT>char *(*(*a[N])())();
</TT><li>Build the declaration up
incrementally,
using
typedefs:
<pre>
	typedef char *pc;	/* pointer to char */
	typedef pc fpc();	/* function returning pointer to char */
	typedef fpc *pfpc;	/* pointer to above */
	typedef pfpc fpfpc();	/* function returning... */
	typedef fpfpc *pfpfpc;	/* pointer to... */
	pfpfpc a[N];		/* array of... */
</pre>
<li>Use the
<TT>cdecl</TT> program,
which turns English into C and vice versa.
You
provide
a longhand description of the type you want,
and <TT>cdecl</TT> responds with the equivalent C declaration:
<pre>
	cdecl&gt; declare a as array of pointer to function returning
		pointer to function returning pointer to char

	char *(*(*a[])())()
</pre>
<TT>cdecl</TT> can also explain complicated declarations
(you
give it
a complicated declaration
and it responds with an English description),
help with casts,
and indicate which set of parentheses the parameters go in
(for complicated function definitions, like the
one
above).
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=resources#tools">18.1</a>.
</OL></p><p>C's declarations
can be confusing
because
they come in two parts:
a base type,
and a <a href="../sx1/index.html#declarator"><dfn>declarator</dfn></a>

which contains the identifier or name being declared,
perhaps along with <TT>*</TT>'s and <TT>[]</TT>'s and <TT>()</TT>'s
saying whether the name is
a pointer to, array of, or function returning
the base type,
or some combination.<a href="modifs.html" rel=subdocument>[footnote]</a>
For example, in
<pre>
	char *pc;
</pre>
the base type is <TT>char</TT>,
the identifier is <TT>pc</TT>,
and the declarator is <TT>*pc</TT>;
this tells us
that <TT>*pc</TT> is a <TT>char</TT>
(this

is what
``declaration mimics use''

means).
</p><p>One way to
make sense
of complicated C declarations
is
by reading them ``inside out,''
remembering that <TT>[]</TT> and <TT>()</TT>
bind more tightly than <TT>*</TT>.
For example, given
<pre>
	char *(*pfpc)();
</pre>
we can see that <TT>pfpc</TT> is a pointer
(the inner <TT>*</TT>)
to a function
(the <TT>()</TT>)
to a pointer
(the outer <TT>*</TT>)
to <TT>char</TT>.
When we later use <TT>pfpc</TT>,
the expression
<TT>*(*pfpc)()</TT>
(the value pointed to by the return value
of a function pointed to by <TT>pfpc</TT>)
will be
a
<TT>char</TT>.
</p><p>Another way of analyzing these declarations is to decompose the 
declarator while composing the description, maintaining the 
``declaration mimics use'' relationship:
<br>
<br>
<pre>
	<TT>*(*pfpc)()</TT>	is a	<TT>char</TT>
	<TT>(*pfpc)()</TT>	is a	pointer to <TT>char</TT>
	<TT>(*pfpc)</TT>	is a	function returning pointer to <TT>char</TT>
	<TT>pfpc</TT>	is a	pointer to function returning pointer to <TT>char</TT>
</pre>
</p><p>If you'd like to make things clearer
when declaring
complicated
types like these,
you can make the analysis explicit
by using
a chain of typedefs
as in option
2 above.
</p><p>The pointer-to-function declarations in
the examples above
have not
included
parameter type information.
When the parameters have complicated types,
declarations can <em>really</em> get
messy.
(Modern versions of <TT>cdecl</TT> can help here, too.)
</p><p>Additional links:
<br>
<br>
A message of mine explaining the
<!-- beware: relative url -->

<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#ptrary2">difference between array-of-pointer vs. pointer-to-array declarations</a>
<br>
<br>




David Anderson's
``<a href="spiral.anderson.html">Clockwise/Spiral Rule</a>''
</p>





<p>References:

K&amp;R2 Sec. 5.12 p. 122
<br>
ISO Sec. 6.5ff (esp. Sec. 6.5.4)
<br>
H&amp;S Sec. 4.5 pp. 85-92, Sec. 5.10.1 pp. 149-50
<hr><hr><hr>
<a name="recurfuncp">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/recurfuncp.html"><!-- qtag -->Question 1.22</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>



How can I declare a function

that can return
a pointer to a function
of the same type?
I'm building a state machine with one function
for each state, each of which returns a pointer to the function for
the next state.
But I can't find a way to declare the
functions--I seem
to need a function
returning a pointer to a function
returning a pointer to a function
returning a pointer to a function...,
ad infinitum.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
You can't quite do it

directly.
One way is to
have the function return
a generic function pointer
(see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=ptrs#generic">4.13</a>),
with some judicious casts
to adjust the types
as the pointers are passed around:
<pre>
typedef int (*funcptr)();	  /* generic function pointer */
typedef funcptr (*ptrfuncptr)();  /* ptr to fcn returning g.f.p. */

funcptr start(), stop();
funcptr state1(), state2(), state3();

void statemachine()
{
	ptrfuncptr state = start;

	while(state != stop)
		state = (ptrfuncptr)(*state)();
}

funcptr start()
{
	return (funcptr)state1;
}
</pre>
(The second <TT>ptrfuncptr</TT> typedef hides some particularly 
dark
syntax;
without it,
the <TT>state</TT> variable
would have to be declared as <TT>funcptr&nbsp;(*state)()</TT>
and the call would contain a bewildering cast of the form
<TT>(funcptr&nbsp;(*)())(*state)()</TT>.)
</p><p>Another way
(suggested
by
Paul Eggert,
Eugene Ressler,
Chris Volpe,
and perhaps others)
is to
have
each function
return a structure


containing only
a pointer to a function returning
that structure:
<pre>
struct functhunk {
	struct functhunk (*func)();
};

struct functhunk start(), stop();
struct functhunk state1(), state2(), state3();

void statemachine()
{
	struct functhunk state = {start};

	while(state.func != stop)
		state = (*state.func)();
}

struct functhunk start()
{
	struct functhunk ret;
	ret.func = state1;
	return ret;
}
</pre>
(Note that these examples use
the older, explicit style
of calling via function pointers;
see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=ptrs#funccall">4.12</a>.
See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#pfitypedef">1.17</a>.)
<hr><hr><hr>
<a name="dynarray">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/dynarray.html"><!-- qtag -->Question 1.23</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Can I declare a local array
(or parameter array)
of a size matching a passed-in array,
or set by another parameter?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Historically, you couldn't,
but in C99
(and in some pre-C99 compilers with extensions)
you can.
See questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#dynlocarys">6.15</a> and <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#ary2dfunc2">6.19</a>.
<hr><hr><hr>
<a name="extarraysize">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/extarraysize.html"><!-- qtag -->Question 1.24</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
I have an <TT>extern</TT> array
which is defined
in
one file,
and used in another:
<pre>
<I>file1.c:</I>			<I>file2.c:</I>

int array[] = {1, 2, 3};	extern int array[];
</pre>
Why doesn't <TT>sizeof</TT> work on
<TT>array</TT> in <TT>file2.c</TT>?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
An <TT>extern</TT> array of unspecified size
is an incomplete type; 
you cannot apply <TT>sizeof</TT> to it.
<TT>sizeof</TT> operates at compile time,
and
there is no way for it to learn the size of an
array
which is defined in another file.
</p><p>You have three options:
<OL><li>Declare a companion variable,
containing the size of the array,
defined and initialized (with <TT>sizeof</TT>)
in the same source file where the array is defined:
<pre>
<I>file1.c:</I>			<I>file2.c:</I>

int array[] = {1, 2, 3};	extern int array[];
int arraysz = sizeof(array);	extern int arraysz;
</pre>
(See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#arraynels">6.23</a>.)
<li><TT>#define</TT> a manifest constant
for the size
so
that
it can be used consistently in the definition
and the <TT>extern</TT> declaration:
<pre>
<I>file1.h:</I>

#define ARRAYSZ 3
extern int array[ARRAYSZ];

<I>file1.c:</I>			<I>file2.c:</I>

#include "file1.h"		#include "file1.h"
int array[ARRAYSZ];
</pre>
<li>Use
some sentinel value
(typically <TT>0</TT>, <TT>-1</TT>, or <TT>NULL</TT>)
in
the array's last element,
so
that code can determine the end
without an explicit size indication:
<pre>
<I>file1.c:</I>			<I>file2.c:</I>

int array[] = {1, 2, 3, -1};	extern int array[];
</pre>
</OL>(Obviously,
the choice will depend to some extent
on whether the array was already being initialized;
if it was,
option 2 is poor.)
</p><p>See also question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryparmsize">6.21</a>.

</p>



<p>References:

H&amp;S Sec. 7.5.2 p. 195
<hr><hr><hr>
<a name="implfdecl">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/implfdecl.html"><!-- qtag -->Question 1.25</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
My compiler is complaining
about an invalid redeclaration of a function,
but I only define it once
and call it once.

</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Functions which are called without a declaration in scope,
perhaps because the first call precedes the function's definition,
are assumed
to be declared as
if by:
<pre>
	extern int f();
</pre>
That is,
an undeclared function is assumed to return <TT>int</TT>,
and to accept an unspecified number of arguments
(though there must be a fixed number of them

and none may be ``narrow'').
If the function is later defined otherwise,
the compiler complains about the discrepancy.
Functions returning other than <TT>int</TT>,
or accepting any ``narrow'' arguments,
or accepting a variable number of arguments,

must all be declared before they are called.
(And it's by all means
safest to declare all functions,
so that function prototypes can
check that arguments are passed correctly.)
</p><p>


Another possible source of this problem is that the function has the same
name as
another
one declared in
some header file.
</p><p>


See also questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=ansi#argpromos">11.3</a>
and <a href="/~scs/cgi-bin/faqcat.cgi?sec=varargs#protos">15.1</a>.
</p>



<p>References:

K&amp;R1 Sec. 4.2 p. 70
<br>
K&amp;R2 Sec. 4.2 p. 72
<br>
ISO Sec. 6.3.2.2
<br>
H&amp;S Sec. 4.7 p. 101
<hr><hr><hr>
<a name="main">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/main.html"><!-- qtag -->Question 1.25b</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What's the right declaration for <TT>main</TT>?
<br>Is <TT>void&nbsp;main()</TT> correct?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
See questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=ansi#maindecl">11.12a</a>
through
<a href="/~scs/cgi-bin/faqcat.cgi?sec=ansi#voidmainbooks">11.15</a>.
(But no, it's not correct.)
<hr><hr><hr>
<a name="argpromo">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/argpromo.html"><!-- qtag -->Question 1.26</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
My compiler is complaining about mismatched function prototypes
which look fine to me.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=ansi#argpromos">11.3</a>.
<hr><hr><hr>
<a name="headerglom">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/headerglom.html"><!-- qtag -->Question 1.27</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
I'm getting strange
syntax errors
on the very first
declaration in
a file,
but it looks fine.

</p>
<p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=cpp#headerglom">10.9</a>.
<hr><hr><hr>
<a name="bigdatastr">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/bigdatastr.html"><!-- qtag -->Question 1.28</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
My compiler isn't letting me declare a big array

like
<pre>
double array[256][256];</pre>

</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#bigdatastr">19.23</a>,
and maybe <a href="/~scs/cgi-bin/faqcat.cgi?sec=malloc#sizewrap">7.16</a>.
<hr><hr><hr>
<a name="namespace">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/namespace.html"><!-- qtag -->Question 1.29</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I determine
which identifiers are safe for me to use
and which are reserved?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Namespace management can be a sticky issue.
The problem--which isn't always
obvious--is that you don't want
to pick identifiers already in use by the implementation,

such that
you
get
``multiply defined'' errors
or--even worse--quietly
replace
one of the implementation's 
symbols
and
break
everything.
You also want some guarantee that later releases

won't usurp names
you're legitimately using.
<a href="internal.html" rel=subdocument>[footnote]</a>
(Few things are more frustrating
than taking a debugged, working, production program,
recompiling it under a new release of a compiler,
and having the build fail
due to namespace or other problems.)
Therefore,
the ANSI/ISO C Standard contains rather elaborate definitions
carving out distinct namespace subsets
for the user and the implementation.
</p><p>To make sense of ANSI's rules,
and
before we can say whether a given identifier is reserved,
we must understand three attributes of

the identifier:
its scope, namespace, and linkage.
</p><p>There are four kinds of scope
(regions over which an
identifier's declaration is in effect)
in C:

function,
file,
block,
and
prototype.
(The fourth
one

exists only in the parameter lists
of function prototype declarations;
see also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=ansi#structinproto">11.5</a>.)
</p><p>There are four different kinds of namespaces,
for:

<UL><li>labels
(i.e. <TT>goto</TT> targets);
<li>tags
(names of structures, unions,
and

enumerations;
these
three
aren't separate even though they theoretically could be);
<li>structure/union members
(one namespace per structure or union);
and
<li>everything else
(functions, variables, typedef names, enumeration constants),
termed ``ordinary identifiers'' by the Standard.
</UL></p><p>Another set of names
(though not termed a ``namespace'' by the Standard)
consists of preprocessor macros;
these are all expanded
before the compiler gets around to considering the four formal namespaces.
</p><p>The standard defines three kinds of ``linkage'':

external, internal, and none.
For our purposes,
external linkage means global,
non-<TT>static</TT> variables and functions
(across all source files),
internal linkage means <TT>static</TT> variables and functions
with file scope,
and
``no linkage''
refers to local variables,
and also things like typedef names and enumeration constants.

</p><p>The rules,
paraphrased from
ANSI Sec. 4.1.2.1,
are:
</p><UL><li>1.
All
identifiers beginning with an underscore
followed by an upper-case letter or another underscore
are always reserved
(all scopes, all namespaces).
<li>2.
All
identifiers beginning with an underscore
are reserved for ordinary identifiers
(functions, variables, typedefs, enumeration constants)
with file scope.

<li>3.
A
macro name defined in a standard header
is reserved for any use
if


any
header which <TT>#define</TT>s it is <TT>#include</TT>d.
<li>4.
All
standard library identifiers
with external linkage
(e.g. function names)
are always reserved
as identifiers with external linkage.
<li>5.
Typedef

and
tag names,
with file scope,
defined in standard headers,
are reserved at file scope
(in the same namespace)
if the corresponding header is <TT>#include</TT>d.
(The Standard really says
``each identifier with file scope,''
but the only standard identifiers not covered by rule 4
are typedef and tag names.)
</UL><p>Rules 3 and 4
are additionally complicated by the fact that
several sets of macro names and standard library identifiers
are reserved for ``future directions''
that is,
later revisions of the Standard
may define new names matching certain patterns.
</p><p>Here is a list of the patterns which are reserved for 
``future directions''
associared with each standard header:
<blockquote>[TABLE GOES HERE]
</blockquote>(The notation <TT>[A-Z]</TT> means ``any uppercase letter'';
similarly, <TT>[a-z]</TT> and <TT>[0-9]</TT> indicate lower-case 
letters and digits.
The notation <TT>*</TT> means ``anything.''
For example,
the pattern for <TT>&lt;stdlib.h&gt;</TT> says that
all external identifiers beginning with the letters <TT>str</TT>
followed by a lower-case letter
are reserved.)
</p><p>What do the
above
rules really mean?
If you want to be on the safe side:
</p><UL><li>1,2.
Don't
give anything a name
with a leading underscore.
<li>3.
Don't
give anything a name
which is already a
standard macro
(including the ``future directions'' patterns).
<li>4.
Don't
give
any functions or global variables
names
which are already taken by
functions or variables in the standard library,
or
which match
any of the ``future directions'' patterns.
(Strictly speaking, ``matching'' means
matching in the first six characters,
without regard to case;
see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=ansi#extidsignif">11.27</a>.)
<li>5.
Don't redefine standard typedef

or tag names.
</UL><p>In fact,
the preceding
subparagraphs

are overly conservative.
If you wish,
you may

remember the following exceptions:
</p><UL><li>1,2.
You may use identifiers consisting of
an underscore
followed by a digit or lower case letter
for labels and structure/union members.
<li>1,2.
You may use identifiers consisting of
an underscore
followed by a digit or lower case letter
at function, block, or prototype scope.
<li>3.
You may use names matching standard macro names
if you don't <TT>#include</TT> any header files which <TT>#define</TT> them.
<li>4.
You may use names of standard library routines as static or 
local variables
(strictly speaking, as identifiers with internal or no linkage).
<li>5.
You may use standard typedef and tag names
if you don't <TT>#include</TT> any header files which declare them.
</UL><p>However,
before making use of any of these exceptions,
recognize that
some of them are pretty risky
(especially exceptions 3 and 5,
since
you could
accidentally <TT>#include</TT> the relevant header file
at a later time,
perhaps through a chain of nested <TT>#include</TT> files),
and others
(especially the ones labeled 1,2)
represent sort of a ``no man's land''

between the user namespaces
and the namespaces reserved to the implementation.
</p><p>One reason for providing these exceptions
is to allow the implementors
of various add-in libraries
a way to declare
their own
internal or
``hidden'' identifiers.
If you make use of any of the exceptions,
you won't clash with any identifiers defined by the Standard,
but you might clash with something
defined by a third-party library you're using.
(If,
on the other hand,
you're
the one who's

implementing an add-on library,
you're welcome to make use of them,
if necessary,
and if you're careful.)
</p><p>
(It <em>is</em>

generally safe to make use of exception 4
to give function parameters
or local variables
names matching standard library routines

or ``future directions'' patterns.
For example,
``<TT>string</TT>''
is a
common--and legal--name
for a
parameter or local variable.)
</p><p>Additional links:
<a href="http://www.concentric.net/~Brownsta/c-predef.htm">Stan Brown's comprehensive list of reserved identifiers</a>
</p>










<p>References:

ISO Sec. 6.1.2.1, Sec. 6.1.2.2, Sec. 6.1.2.3, Sec. 7.1.3, Sec. 7.13
<br>
Rationale Sec. 4.1.2.1
<br>
H&amp;S Sec. 2.5 pp. 21-3, Sec. 4.2.1 p. 67, Sec. 4.2.4 pp. 69-70, Sec. 4.2.7 p. 78, Sec. 10.1 p. 284
<hr><hr><hr>
<a name="initval">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/initval.html"><!-- qtag -->Question 1.30</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What
am I allowed to
assume about the initial values of variables
and arrays
which are not explicitly initialized?
<br>If global variables start out as ``zero'',
is that good enough
for null pointers and floating-point zeroes?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Uninitialized
variables
with
<a href="../sx1/index.html#static"><dfn>static</dfn></a>
duration

(that is,
those declared outside of functions,
and those declared with the storage class <TT>static</TT>),
are guaranteed
to
start out as
zero,
just
as if the programmer had typed ``<TT>=&nbsp;0</TT>''
or ``<TT>=&nbsp;{0}</TT>''.
Therefore,
such variables are
implicitly
initialized
to the null pointer
(of the correct type;
see also section
<a href="/~scs/cgi-bin/faqcat.cgi?sec=null#index">5</a>)
if they are pointers,
and
to 0.0 if they are floating-point.
<a href="zerofill.html" rel=subdocument>[footnote]</a>
</p><p>Variables with
<a href="../sx1/index.html#automatic"><dfn>automatic</dfn></a>
duration
(i.e. local variables without the <TT>static</TT> storage class)
start out containing garbage,
unless they are explicitly initialized.
(Nothing useful can be predicted about the garbage.)
If they
do have initializers,
they are initialized each time the function
is
called
(or,
for variables local to inner blocks,
each time the block is entered
at the
top<a href="jumpinto.html" rel=subdocument>[footnote]</a>
).
</p><p>These rules do apply to arrays and structures
(termed <a href="../sx1/index.html#aggregates"><dfn>aggregates</dfn></a>);
arrays and structures are considered ``variables''
as far as initialization is concerned.
When
an automatic array or structure
has
a partial initializer,
the remainder
is initialized to 0,
just as for statics.
<a href="krerr.html" rel=subdocument>[footnote]</a>
See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#autoaggrinit">1.31</a>.
</p><p>Finally,
dynamically-allocated memory
obtained with <TT>malloc</TT> and <TT>realloc</TT>
is likely to contain garbage,
and must be initialized by the calling program,
as appropriate.
Memory obtained with <TT>calloc</TT>
is
all-bits-0,
but this is not necessarily useful
for pointer or floating-point values
(see question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=malloc#calloc">7.31</a>,
and section
<a href="/~scs/cgi-bin/faqcat.cgi?sec=null#index">5</a>).
</p>












<p>References:

K&amp;R1 Sec. 4.9 pp. 82-4
<br>
K&amp;R2 Sec. 4.9 pp. 85-86
<br>
ISO Sec. 6.5.7, Sec. 7.10.3.1, Sec. 7.10.5.3
<br>
H&amp;S Sec. 4.2.8 pp. 72-3, Sec. 4.6 pp. 92-3, Sec. 4.6.2 pp. 94-5, Sec. 4.6.3 p. 96, Sec. 16.1 p. 386
<hr><hr><hr>
<a name="autoaggrinit">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/autoaggrinit.html"><!-- qtag -->Question 1.31</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
This code, straight out of a book, isn't compiling:
<pre>
int f()
{
	char a[] = "Hello, world!";
}
</pre>
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Perhaps you have
an old,
pre-ANSI compiler,
which doesn't allow initialization of ``automatic aggregates''
(i.e. non-<TT>static</TT> local arrays, structures,
or
unions).
You have four possible workarounds:
<OL><li>If
the array won't be written to
or if
you won't need a fresh copy
during
any
subsequent calls,
you can declare it <TT>static</TT>
(or perhaps make it global).
<li>If
the array won't be written to,
you could
replace it with a pointer:
<pre>
	f()
	{
		char *a = "Hello, world!";
	}
</pre>
You
can always initialize local <TT>char&nbsp;*</TT> variables



to point to
string literals
(but
see question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#strlitinit">1.32</a>).
<li>If neither of
the above
conditions hold,
you'll have to



initialize
the array
by hand
with <TT>strcpy</TT>
when
the function
is called:
<pre>
	f()
	{
		char a[14];
		strcpy(a, "Hello, world!");
	}
</pre>
<li>Get an ANSI-compatible compiler.
</OL></p><p>See also question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=ansi#preansi">11.29a</a>.
<hr><hr><hr>
<a name="fcninit">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/fcninit.html"><!-- qtag -->Question 1.31b</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What's wrong with
this initialization?
<pre>
char *p = malloc(10);</pre>

My compiler is complaining about
an ``invalid initializer'',
or something.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Is
the declaration of a
static or non-local variable?
Function calls are
allowed
in initializers
only
for
automatic
variables
(that is, for local, non-<TT>static</TT> variables).
<hr><hr><hr>
<a name="strlitinit">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/strlitinit.html"><!-- qtag -->Question 1.32</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What is the difference between
these initializations?
<pre>
char a[] = "string literal";
char *p  = "string literal";
</pre>
My program
crashes if
I try to
assign a new value to <TT>p[i]</TT>.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
A string literal
(the formal
term
for a double-quoted string in C source)
can
be used in
two slightly different
ways:
<OL><li>
As
the initializer for an array of <TT>char</TT>,
as in the
declaration of <TT>char&nbsp;a[]</TT>
,
it specifies the initial values of the characters in that array

(and, if necessary, its size).
<li>Anywhere else,
it turns into an unnamed,
static
array of characters,
and this unnamed array
may be stored in read-only memory,
and which therefore cannot necessarily be modified.
In
an expression context,
the
array is converted at once
to a pointer,
as usual
(see section <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#index">6</a>),
so
the second declaration initializes
<TT>p</TT>
to point to
the
unnamed
array's
first element.
</OL></p><p>

Some
compilers
have a switch controlling whether
string literals
are writable
or not
(for compiling old code),
and some
may

have options to cause string literals to be
formally
treated as arrays of <TT>const</TT> <TT>char</TT>
(for better error catching).
</p><p>See also questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#autoaggrinit">1.31</a>,
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryptr1">6.1</a>,
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryptr2">6.2</a>,
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#practdiff">6.8</a>,
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=ansi#strlitnotconst">11.8b</a>.
</p>




<p>References:

K&amp;R2 Sec. 5.5 p. 104
<br>
ISO Sec. 6.1.4, Sec. 6.5.7
<br>
Rationale Sec. 3.1.4
<br>
H&amp;S Sec. 2.7.4 pp. 31-2
<hr><hr><hr>
<a name="nonstring">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/nonstring.html"><!-- qtag -->Question 1.33</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Is <TT>char&nbsp;a[3]&nbsp;=&nbsp;"abc";</TT> legal?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Yes.
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=ansi#nonstrings">11.22</a>.
<hr><hr><hr>
<a name="ptrfuncinit">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/ptrfuncinit.html"><!-- qtag -->Question 1.34</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
I finally figured out the syntax for declaring pointers to
functions, but now how do I initialize one?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Use something like
<pre>
extern int func();
int (*fp)() = func;</pre>

</p><p>When the name of a function appears in an expression,
it ``decays'' into a pointer
(that is,
it has its address implicitly taken),
much as an array name does.
</p><p>A prior,
explicit
declaration for the function
(perhaps in a header file)
is normally
needed,
as shown.
The
implicit external function declaration
that can occur when a function is called
does not help when a function name's only use is for its value.
</p><p>See also questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#implfdecl">1.25</a>
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=ptrs#funccall">4.12</a>.

<hr><hr><hr>
<a name="initunion">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../decl/initunion.html"><!-- qtag -->Question 1.35</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Can I initialize unions?
</p>
<p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=struct#initunion">2.20</a>.
<hr><hr><hr>
<hr>
<p>
Read sequentially:
<a href="/~scs/cgi-bin/faqcat.cgi?sec=" rev=precedes>prev</a>
<a href="/~scs/cgi-bin/faqcat.cgi?sec=struct" rel=precedes>next</a>
<a href="/~scs/cgi-bin/faqcat.cgi" rev=subdocument>up</a>
</p>
<hr>
<p>
<br><!-- lastfooter -->
<a href="../about.html">about this FAQ list</a>
&nbsp;
<a href="../eskimo.html">about eskimo</a>
&nbsp;
<a href="../search.html">search</a>
&nbsp;
<a href="../feedback.html">feedback</a>
&nbsp;
<a href="copyright.html">copyright</a>
<p>
Hosted by
<a href="http://www.eskimo.com/"><img src="http://www.eskimo.com/img/link/eskitiny.gif" alt="Eskimo North"></a>
</body>
</html>
