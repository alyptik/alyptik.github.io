<!DOCTYPE HTML PUBLIC "-//W3O//DTD W3 HTML 2.0//EN">
<!-- This collection of hypertext pages is Copyright 1995-2005 by Steve Summit. -->
<!-- Content from the book "C Programming FAQs: Frequently Asked Questions" -->
<!-- (Addison-Wesley, 1995, ISBN 0-201-84519-9) is made available here by -->
<!-- permission of the author and the publisher as a service to the community. -->
<!-- It is intended to complement the use of the published text -->
<!-- and is protected by international copyright laws. -->
<!-- The on-line content may be accessed freely for personal use -->
<!-- but may not be published or retransmitted without explicit permission. -->
<!-- -->
<!-- this page built Sat Dec 24 21:47:45 2005 by faqproc version 2.7 -->
<!-- from source file aryptr.sgml dated Wed Dec 21 12:50:38 2005 -->
<!-- corresponding to FAQ list version 4.0 -->
<html>
<head>
<base href="http://c-faq.com/aryptr/index.html">
<meta name=GENERATOR content="faqproc">
<title>Arrays and Pointers</title>
</head>
<body bgcolor="#ffffff">
<H1>6. Arrays and Pointers</H1>
<a name="aryptr1">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/aryptr1.html"><!-- qtag -->Question 6.1</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
I had the definition <TT>char&nbsp;a[6]</TT> in one source file, and in
another I declared <TT>extern&nbsp;char&nbsp;*a</TT>.
Why didn't it work?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
In one source file you defined an array of characters
and in the other you declared a pointer to characters.
The declaration <TT>extern&nbsp;char&nbsp;*a</TT>
does not declare an array and therefore
does not match the actual
definition.
The type pointer-to-type-T is not the same as
array-of-type-T.

Use <TT>extern&nbsp;char&nbsp;a[]</TT>.
</p>


<p>References:

ISO Sec. 6.5.4.2
<br>
CT&amp;P Sec. 3.3 pp. 33-4, Sec. 4.5 pp. 64-5
<hr><hr><hr>
<a name="aryptr2">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/aryptr2.html"><!-- qtag -->Question 6.2</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
But I heard that <TT>char a[]</TT> was identical to <TT>char&nbsp;*a</TT>.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Not at all.
(What you heard has to do with formal parameters to functions;
see question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryptrparam">6.4</a>.)
Arrays are not pointers,
though they are closely related
(see question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryptrequiv">6.3</a>)
and can be used similarly
(see questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=ptrs#goodfor">4.1</a>,
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#practdiff">6.8</a>,
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#ptrkindofary">6.10</a>,
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#dynarray">6.14</a>).
</p><p>The array declaration
<TT>char&nbsp;a[6]</TT>
requests that space for six characters be set aside,
to be known by the name ``<TT>a</TT>''.

That is,
there is a location named ``<TT>a</TT>''
at which six characters can sit.
The pointer declaration
<TT>char&nbsp;*p</TT>,
on the other hand,
requests a place which holds a pointer,
to be known by the name ``<TT>p</TT>''.
This
pointer can point almost anywhere:
to any <TT>char</TT>,
or to any contiguous array of <TT>char</TT>s,
or nowhere

<a href="anywhere.html" rel=subdocument>[footnote]</a>
(see also questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=null#null1">5.1</a>

and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#initval">1.30</a>).
</p><p>As usual, a picture is worth a thousand words.

The declarations
<pre>
	char a[] = "hello";
	char *p = "world";
</pre>
would initialize data structures which could be represented like this:
<p>
<img src="aryptrstring.gif">
<br>
</p><p>It is useful to realize


that a
reference like <I fallback=no>x</I><TT>[3]</TT>

generates different
code depending on whether <I fallback=no>x</I> is an array or a pointer.
Given the declarations above,
when the compiler sees the expression <TT>a[3]</TT>,
it emits code to start

at the location ``<TT>a</TT>'',
move three past it,
and fetch the character there.
When it
sees the expression <TT>p[3]</TT>,
it emits code to start at the location ``<TT>p</TT>'',

fetch the pointer value there,
add three to the pointer,
and finally fetch the character pointed to.
In other words,



<TT>a[3]</TT> is three places past
(the start of)
the object <em>named</em> <TT>a</TT>,
while <TT>p[3]</TT> is three places past the object
<em>pointed to</em> by
<TT>p</TT>.
In the example above,
both <TT>a[3]</TT> and <TT>p[3]</TT>
happen to be the character 'l',

but the compiler gets there differently.

(The essential difference is that
the values of
an array like <TT>a</TT>
and a pointer like <TT>p</TT>
are computed differently <em>whenever</em> they appear in expressions,
whether or not they are being subscripted,
as explained further in
question <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryptrequiv">6.3</a>.)
See also question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#strlitinit">1.32</a>.
</p>


<p>References:

K&amp;R2 Sec. 5.5 p. 104
<br>
CT&amp;P Sec. 4.5 pp. 64-5
<hr><hr><hr>
<a name="aryptrequiv">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/aryptrequiv.html"><!-- qtag -->Question 6.3</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
So what is meant by the ``equivalence of pointers and arrays'' in C?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Much of the confusion surrounding
arrays and
pointers in C can be traced to
a misunderstanding of
this statement.
Saying that arrays and pointers are ``equivalent''
means
neither
that they are
identical
nor
even
interchangeable.
What it means is that array and pointer arithmetic is defined
such that a pointer can be conveniently used
to access an array
or to simulate an array.
In other words, as Wayne Throop has put it,
it's




``pointer <em>arithmetic</em> and array <em>indexing</em>
[that]
are equivalent in C, pointers and arrays are <em>different</em>.'')
</p><p>Specifically,
the cornerstone of the equivalence is this
key definition:
<blockquote>A reference to an object

of type array-of-T
which appears in an
expression
decays

(with three exceptions)
into a pointer to its first element;
the type of the resultant pointer is pointer-to-T.
</blockquote></p><p>That is,
whenever an array appears in an expression,
the compiler implicitly generates a pointer to the array's
first element,
just as if the programmer had written <TT>&amp;a[0]</TT>.
(The exceptions are when the array is the operand of
a <TT>sizeof</TT>
or
<TT>&amp;</TT>
operator,
or is a string literal initializer for a character
array.
<a href="stringw.html" rel=subdocument>[footnote]</a>
See questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#arraynels">6.23</a>,
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryvsadr">6.12</a>,
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#strlitinit">1.32</a>,
respectively.)
</p><p>As a consequence of
this definition,
and in spite of the fact that
the underlying arrays and pointers are quite different,
the compiler doesn't apply the array subscripting operator
<TT>[]</TT>
that differently
to arrays and pointers,
after all.<a href="fn28.html" rel=subdocument>[footnote]</a>

Given an array <TT>a</TT> and pointer <TT>p</TT>,
an expression of the form <TT>a[i]</TT>
causes the array to decay
into a pointer,
following the rule above,
and
then to be
subscripted just as would be a pointer variable in
the expression <TT>p[i]</TT>
(although the eventual memory accesses will be different,
as explained in question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryptr2">6.2</a>).
If you were to assign the array's address to the pointer:
<pre>
	p = a;
</pre>



then <TT>p[3]</TT> and <TT>a[3]</TT> would access the same element.
</p><p>This
harmony

of access explains how pointers can access arrays,
serve in their stead as function parameters
(see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryptrparam">6.4</a>),
and simulate dynamic arrays
(see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#dynarray">6.14</a>).
</p><p>See also 
questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#practdiff">6.8</a>, <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#ptrkindofary">6.10</a>, and <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#dynarray">6.14</a>.

</p>






<p>References:

K&amp;R1 Sec. 5.3 pp. 93-6
<br>
K&amp;R2 Sec. 5.3 p. 99
<br>
ISO Sec. 6.2.2.1, Sec. 6.3.2.1, Sec. 6.3.6
<br>
H&amp;S Sec. 5.4.1 p. 124
<hr><hr><hr>
<a name="aryptrparam">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/aryptrparam.html"><!-- qtag -->Question 6.4</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
If they're so different,
then

why
are array and pointer declarations interchangeable as
function formal parameters?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
It's
supposed to be
a convenience.
</p><p>Since arrays decay immediately into pointers,
an array is never actually passed to a function.
You can
pretend that
a function receives an array as
a
parameter,
and
illustrate it
by declaring the
corresponding
parameter as an array:
<pre>
	void f(char a[])
	{ ... }
</pre>
Interpreted literally,
this declaration would have no use,
so
the compiler turns
around and pretends

that you'd written a pointer declaration,
since that's what the function will in fact receive:
<pre>
	void f(char *a)
	{ ... }
</pre>
There's nothing
particularly

wrong with talking about a function
as if it
``receives'' an array,
if

the function is traditionally used to operate on 
arrays,
or if
the parameter is naturally treated within the function as an array.
</p><p>This conversion
of array-like declarators into pointers
holds only within function
formal parameter declarations,

nowhere else.

If the conversion bothers you,
you're under no compulsion

to make use of

it;
many programmers
have concluded that the confusion it causes outweighs
the small advantage of having the declaration ``look like'' the call
or the uses within the function.
(Note that the conversion happens only once;
something like <TT>char&nbsp;a2[][]</TT> won't work.
See questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#pass2dary">6.18</a>
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#ary2dfunc2">6.19</a>.)
</p><p>See also question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryparmsize">6.21</a>.
</p>










<p>References:

K&amp;R1 Sec. 5.3 p. 95, Sec. A10.1 p. 205
<br>
K&amp;R2 Sec. 5.3 p. 100, Sec. A8.6.3 p. 218, Sec. A10.1 p. 226
<br>
ISO Sec. 6.5.4.3, Sec. 6.7.1, Sec. 6.9.6
<br>
H&amp;S Sec. 9.3 p. 271
<br>
CT&amp;P Sec. 3.3 pp. 33-4
<br>
Dennis Ritchie, ``The Development of the C Language''

<hr><hr><hr>
<a name="arypbref">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/arypbref.html"><!-- qtag -->Question 6.4b</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
So arrays are passed by reference,
even though the rest of C uses pass by value?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
That's one way of thinking about it.
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=ptrs#passbyref">4.11</a>.
<hr><hr><hr>
<a name="arrayassign">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/arrayassign.html"><!-- qtag -->Question 6.5</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Why can't
I
do something like this?
<pre>
	extern char *getpass();
	char str[10];
	str = getpass("Enter password: ");
</pre>
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Arrays are ``second-class citizens''

in C;
one upshot of this prejudice is that you cannot assign to them
(see also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#arraylval">6.7</a>).
When you need to copy the contents of one array to another,
you must do so explicitly.
In the case of <TT>char</TT> arrays,
the <TT>strcpy</TT> routine is usually appropriate:
<pre>
	strcpy(str, getpass("Enter password: "));
</pre>
</p><p>(When you want to
pass arrays around
without copying them,
you can use pointers and simple assignment.
See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=ptrs#goodfor">4.1</a>.)
</p><p>See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=charstring#stringeq">8.2</a>.
</p>


<p>References:

ISO Sec. 6.2.2.1
<br>
H&amp;S Sec. 7.9.1 pp. 221-2
<hr><hr><hr>
<a name="aryparmasgn">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/aryparmasgn.html"><!-- qtag -->Question 6.6</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
If you can't assign to arrays,
then
how can
<pre>
	int f(char str[])
	{
		if(str[0] == '\0')
			str = "none";
		...
	}
</pre>
work?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
In this code,
<TT>str</TT> is a function parameter,
so its declaration is rewritten by the compiler
as described in question <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryptrparam">6.4</a>.
In other words, <TT>str</TT> <em>is</em> a pointer
(of type <TT>char&nbsp;*</TT>),
and it is 
legal to
assign to
it.
<hr><hr><hr>
<a name="aryasgn3">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/aryasgn3.html"><!-- qtag -->Question 6.6b</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
And what about this?
Isn't this an array assignment?
<pre>
	char a[] = "Hello, world!\n";
</pre>
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
No, that's an initialization.
You <em>are</em> allowed to initialize arrays when you define them.
<hr><hr><hr>
<a name="arraylval">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/arraylval.html"><!-- qtag -->Question 6.7</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can an array be an lvalue, if you can't assign to it?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
The term ``lvalue'' doesn't quite mean
``something you can assign to'';
a better definition is
``something that has a <B>l</B>ocation

(in memory).''
<a href="lvalue.html" rel=subdocument>[footnote]</a>
The ANSI/ISO C Standard goes on to define a
``modifiable lvalue'';
an array

is not a modifiable lvalue.
See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#arrayassign">6.5</a>.

</p>


<p>References:

ISO Sec. 6.2.2.1
<br>
Rationale Sec. 3.2.2.1
<br>
H&amp;S Sec. 7.1 p. 179
<hr><hr><hr>
<a name="practdiff">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/practdiff.html"><!-- qtag -->Question 6.8</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Practically speaking,
what
is the
difference between arrays and pointers?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
An array is a single,
preallocated
chunk of contiguous elements
(all of the same type),
fixed in size and location.
A pointer is a reference to any data element
(of a particular type)
anywhere.
A pointer
must be assigned to point to space allocated elsewhere,
but it can be reassigned
(and the space, if derived from <TT>malloc</TT>, can be resized)
at any time.
A pointer can point to an array,
and can simulate
(along with <TT>malloc</TT>)
a dynamically allocated array,
but a pointer is a much more general data structure
(see also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=ptrs#goodfor">4.1</a>).
</p><p>Due to the



so-called
equivalence of arrays and pointers
(see question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryptrequiv">6.3</a>),
arrays and pointers often seem interchangeable,
and in particular a pointer to a block of memory
assigned by <TT>malloc</TT> is frequently treated
(and can be referenced
using <TT>[]</TT>)
exactly
as if it were a true array.
See questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#dynarray">6.14</a>

and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#dynmuldimary">6.16</a>.
(Be careful with <TT>sizeof</TT>;
see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=malloc#sizeof">7.28</a>.)
</p><p>See also
questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#strlitinit">1.32</a>, <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#ptrkindofary">6.10</a>, and <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#eff2">20.14</a>.
<hr><hr><hr>
<a name="constptr">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/constptr.html"><!-- qtag -->Question 6.9</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Someone explained to me that arrays were really just constant pointers.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
This

is a bit of an oversimplification.
An array name is ``constant''
in that it cannot be assigned to,
but an array is
<em>not</em>
a pointer,
as the discussion and pictures in
question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryptr2">6.2</a>
should make clear.
See also
questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryptrequiv">6.3</a>, <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#practdiff">6.8</a>, and <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#ptrkindofary">6.10</a>.
<hr><hr><hr>
<a name="ptrkindofary">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/ptrkindofary.html"><!-- qtag -->Question 6.10</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
I'm still mystified.

Is a pointer a kind of array,
or is an array a kind of pointer?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
An array is <em>not</em> a pointer,
nor vice versa.
An array <em>reference</em>
(that is,
any mention of an array
in a value context),
<em>turns into</em> a pointer
(see questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryptr2">6.2</a>
and <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryptrequiv">6.3</a>).
</p><p>There are perhaps three ways to think about the situation:
<OL><li>Pointers can simulate arrays
(though that's not all;
see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=ptrs#goodfor">4.1</a>).
<li>There's hardly such a thing as an array
(it is, after all, a ``second-class citizen'');
the subscripting operator <TT>[]</TT> is in fact a pointer operator.
<li>At a higher level of abstraction,
a pointer to a block of memory is
effectively the same
as an array
(though this says nothing about other uses of pointers).
</OL></p><p>But, to reiterate, here are two ways <em>not</em> to think about it:
<OL><li>4.
``They're completely the same.''
(False; see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryptr2">6.2</a>.)
<li>5.
``Arrays are constant pointers.''
(False; see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#constptr">6.9</a>.)
</OL></p><p>See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#practdiff">6.8</a>.
<hr><hr><hr>
<a name="joke">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/joke.html"><!-- qtag -->Question 6.11</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>

I came across some ``joke'' code containing the ``expression''
<TT>5["abcdef"]</TT> .
How can this be legal C?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Yes,
Virginia,
array subscripting is commutative in C.
<a href="commutative.html" rel=subdocument>[footnote]</a>
This curious fact follows from the pointer definition of array
subscripting,

namely that <TT>a[e]</TT> is
identical
to
<TT>*((a)+(e))</TT>,
for
<em>any</em>
two expressions <TT>a</TT> and <TT>e</TT>,
as long as one of them is a pointer expression
and one is integral.
The ``proof'' looks like
<pre>
	a[e]
	*((a) + (e))	<I>(by definition)</I>
	*((e) + (a))	<I>(by commutativity of addition)</I>
	e[a]		<I>(by definition)</I>
</pre>
</p><p>This unsuspected commutativity is often mentioned in C texts
as if it were something to be proud of,
but it finds no useful application
outside of the Obfuscated C Contest
(see question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#ioccc">20.36</a>).
</p><p>Since strings in C are arrays of <TT>char</TT>,
the expression <TT>"abcdef"[5]</TT> is perfectly legal,
and evaluates to the character <TT>'f'</TT>.
You can think of it

as a shorthand for
<pre>
	char *tmpptr = "abcdef";

	... tmpptr[5] ...
</pre>
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#hexio">20.10</a> for a realistic example.

</p>


<p>References:

Rationale Sec. 3.3.2.1
<br>
H&amp;S Sec. 5.4.1 p. 124, Sec. 7.4.1 pp. 186-7
<hr><hr><hr>
<a name="aryvsadr">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/aryvsadr.html"><!-- qtag -->Question 6.12</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Since array references decay into pointers,
if <TT>arr</TT> is an array,
what's
the difference between
<TT>arr</TT> and <TT>&amp;arr</TT>?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>



The type.
</p><p>In
Standard C,
<TT>&amp;arr</TT> yields a pointer,
of type pointer-to-array-of-T,
to the entire array.
(In
pre-ANSI C,
the <TT>&amp;</TT> in <TT>&amp;arr</TT> generally elicited a warning,
and was generally


ignored.)
Under all C compilers,
a
simple
reference
(without an explicit <TT>&amp;</TT>)
to an array
yields a pointer,
of type pointer-to-T,
to the array's first element.
</p><p>For a simple array
<pre>
	int a[10];
</pre>
a reference to <TT>a</TT> has type ``pointer to <TT>int</TT>,''
and <TT>&amp;a</TT> is ``pointer to array of 10 <TT>int</TT>s.''
For a two-dimensional array like
<pre>
	int array[NROWS][NCOLUMNS];
</pre>
a reference to <TT>array</TT> has type
``pointer to array of <TT>NCOLUMNS</TT> <TT>int</TT>s,''
while <TT>&amp;array</TT> has type
``pointer to array of <TT>NROWS</TT> arrays 
of <TT>NCOLUMNS</TT> <TT>int</TT>s.''
</p><p>See
also questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryptrequiv">6.3</a>,
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#ptrtoarray">6.13</a>,
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#pass2dary">6.18</a>.
</p>




<p>References:

ISO Sec. 6.2.2.1, Sec. 6.3.3.2
<br>
Rationale Sec. 3.3.3.2
<br>
H&amp;S Sec. 7.5.6 p. 198
<hr><hr><hr>
<a name="ptrtoarray">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/ptrtoarray.html"><!-- qtag -->Question 6.13</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How do I declare a pointer to an array?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Usually, you don't want to.

When people speak casually of a pointer to an array,
they usually mean a pointer to its first element.
</p><p>Instead of a pointer to an array,
consider
using a pointer to one of the array's elements.
Arrays of type T decay into pointers to type T
(see question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryptrequiv">6.3</a>),
which is convenient;
subscripting or incrementing
the resultant pointer
will access
the
individual members of the array.
True pointers to arrays, when
subscripted or incremented, step
over entire arrays
(see below),
and are generally useful only when operating
on arrays of arrays,
<a href="fn31.html" rel=subdocument>[footnote]</a>
if at all.
(See
also
question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#pass2dary">6.18</a>.)
</p><p>If you really need to declare a pointer to an entire array,
use something like
``<TT>int&nbsp;(*ap)[N];</TT>''
where <TT>N</TT> is the size of the array.
(See also question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#cdecl1">1.21</a>.)
If the size of the array is unknown, <TT>N</TT> can
in principle
be omitted,
but the resulting type, ``pointer to array of unknown size,''
is useless.

</p><p>Here is an example
showing the difference between
simple pointers
and
pointers to arrays.
Given the declarations
<pre>
int a1[3] = {0, 1, 2};
int a2[2][3] = {{3, 4, 5}, {6, 7, 8}};
int *ip;		/* pointer to int */
int (*ap)[3];		/* pointer to array [3] of int */
</pre>
you could use the simple pointer-to-<TT>int</TT>,
<TT>ip</TT>,
to access the one-dimensional array <TT>a1</TT>:
<pre>
	ip = a1;
	printf("%d ", *ip);
	ip++;
	printf("%d\n", *ip);
</pre>
This fragment would print
<pre>
	0 1
</pre>
An attempt to use a pointer-to-array,
<TT>ap</TT>,
on
<TT>a1</TT>:
<pre>
	ap = &amp;a1;
	printf("%d\n", **ap);
	ap++;				/* WRONG */
	printf("%d\n", **ap);		/* undefined */
</pre>
would print <TT>0</TT> on the first line
and something undefined on the second
(and might crash).
The pointer-to-array
would only be at all useful in accessing
an array of arrays,
such as <TT>a2</TT>:
<pre>
	ap = a2;
	printf("%d %d\n", (*ap)[0], (*ap)[1]);
	ap++;		/* steps over entire (sub)array */
	printf("%d %d\n", (*ap)[0], (*ap)[1]);
</pre>
This last fragment
would print
<pre>
	3 4
	6 7
</pre>

</p><p>See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryvsadr">6.12</a>.
</p><p>Additional links:



<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#ptrary2">further reading</a>
</p>
<p>References:

ISO Sec. 6.2.2.1
<hr><hr><hr>
<a name="dynarray">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/dynarray.html"><!-- qtag -->Question 6.14</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I set an array's size at run time?
<br>How can I avoid

fixed-sized arrays?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
The equivalence between arrays and pointers
(see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryptrequiv">6.3</a>)
allows a pointer to <TT>malloc</TT>'ed memory
to simulate an array
quite effectively.
After executing
<pre>
	#include &lt;stdlib.h&gt;
	int *dynarray;
	dynarray = malloc(10 * sizeof(int));
</pre>
(and if the call to <TT>malloc</TT> succeeds),
you can reference <TT>dynarray[i]</TT>
(for <TT>i</TT> from 0 to 9)
almost
as if <TT>dynarray</TT> were a conventional,
statically-allocated array
(<TT>int&nbsp;a[10]</TT>).
The only difference is that
<TT>sizeof</TT> will not
give the size of the ``array''
(see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=malloc#sizeof">7.28</a>.
See also
questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#fcninit">1.31b</a>, <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#dynmuldimary">6.16</a>, <a href="/~scs/cgi-bin/faqcat.cgi?sec=malloc#cast">7.7</a>, and <a href="/~scs/cgi-bin/faqcat.cgi?sec=malloc#realloc">7.29</a>.
<hr><hr><hr>
<a name="dynlocarys">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/dynlocarys.html"><!-- qtag -->Question 6.15</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I declare local arrays of a size matching a passed-in array?

</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Until recently, you
couldn't; array
dimensions
in C
traditionally
had to be
compile-time constants.
However,
C99 introduces
variable-length arrays
(VLA's)
which solve this problem;

local arrays may have sizes set by variables or other expressions,
perhaps involving function parameters.
(<TT>gcc</TT>
has provided parameterized arrays

as an extension
for some time.)
If you can't use C99 or <TT>gcc</TT>,
you'll
have to use <TT>malloc</TT>,
and remember to call <TT>free</TT> before the function returns.
See also questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#dynarray">6.14</a>,
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#dynmuldimary">6.16</a>,
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#ary2dfunc2">6.19</a>,
<a href="/~scs/cgi-bin/faqcat.cgi?sec=malloc#local">7.22</a>,
and maybe <a href="/~scs/cgi-bin/faqcat.cgi?sec=malloc#alloca">7.32</a>.
</p>


<p>References:

ISO Sec. 6.4, Sec. 6.5.4.2
<br>
C9X Sec. 6.5.5.2
<hr><hr><hr>
<a name="dynmuldimary">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/dynmuldimary.html"><!-- qtag -->Question 6.16</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I dynamically allocate a multidimensional array?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
The traditional solution is
to allocate
an array
<a href="arraysim.html" rel=subdocument>[footnote]</a>
of
pointers to
pointers,

and then
initialize


each pointer
to

a dynamically-allocated
``row.''
Here is a two-dimensional example:
<pre>
	#include &lt;stdlib.h&gt;

	int **array1 = malloc(nrows * sizeof(int *));
	for(i = 0; i &lt; nrows; i++)
		array1[i] = malloc(ncolumns * sizeof(int));
</pre>
(In real code, of course,
all of <TT>malloc</TT>'s return values would be checked.

You can also use
<TT>sizeof(*array1)</TT> and <TT>sizeof(**array1)</TT>
instead of
<TT>sizeof(int&nbsp;*)</TT> and <TT>sizeof(int)</TT>;
see <a href="fn33.html" rel=subdocument>[footnote]</a>
.)
</p><p>You can keep the array's contents contiguous,



at the cost of
making later reallocation of individual rows more difficult,
with a bit of explicit pointer arithmetic:
<pre>
	int **array2 = malloc(nrows * sizeof(int *));
	array2[0] = malloc(nrows * ncolumns * sizeof(int));
	for(i = 1; i &lt; nrows; i++)
		array2[i] = array2[0] + i * ncolumns;
</pre>
In either case
(i.e for <TT>array1</TT> or <TT>array2</TT>),
the elements of the dynamic array can be accessed
with normal-looking array subscripts:
<TT>arrayx[i][j]</TT>
(for 0&nbsp;&lt;=&nbsp;<TT>i</TT>&nbsp;&lt;&nbsp;<TT>nrows</TT> and
0&nbsp;&lt;=&nbsp;<TT>j</TT>&nbsp;&lt;&nbsp;<TT>ncolumns</TT>).

Here is
a schematic illustration
of the layout of 
<TT>array1</TT> and <TT>array2</TT>:
<br>
<br>
<img src="array1.gif">
<br>
<br>
<img src="array2.gif">

<p>If the double indirection implied by the above schemes is for
some reason unacceptable,<a href="doubleindir.html" rel=subdocument>[footnote]</a>
you can simulate a two-dimensional
array with a single, dynamically-allocated one-dimensional array:
<pre>
	int *array3 = malloc(nrows * ncolumns * sizeof(int));
</pre>
However, you must now perform subscript calculations manually,
accessing the <TT>i</TT>,<TT>j</TT>th element with
the expression
<pre>
<TT>array3[i&nbsp;*&nbsp;ncolumns&nbsp;+&nbsp;j]</TT>
</pre>
and this array cannot
necessarily

be
passed to functions
which expect
multidimensional arrays.
(A macro
such as
<pre>
	#define Arrayaccess(a, i, j) ((a)[(i) * ncolumns + (j)])
</pre>
could
hide the explicit calculation,
but invoking it
would require
parentheses and commas
which wouldn't look exactly like
conventional C
multidimensional array syntax,
and

the macro
would need
access to at least one of the dimensions,
as well.
See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#ary2dfunc2">6.19</a>.)
</p><p>Yet another option
is to
use pointers to arrays:
<pre>
	int (*array4)[NCOLUMNS] = malloc(nrows * sizeof(*array4));
</pre>
or even


<pre>
	int (*array5)[NROWS][NCOLUMNS] = malloc(sizeof(*array5));
</pre>
but the syntax starts getting horrific
(accesses to <TT>array5</TT> look like <TT>(*array5)[i][j]</TT>),
and
at most one dimension may be specified at run time.
</p><p>
With all of these techniques,
you may of course need to remember to free the arrays
when they are no longer needed;
in the case of <TT>array1</TT> and <TT>array2</TT>
this takes several steps
(see also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=malloc#freeforall">7.23</a>):
<pre>
	for(i = 0; i &lt; nrows; i++)
		free((void *)array1[i]);
	free((void *)array1);

	free((void *)array2[0]);
	free((void *)array2);
</pre>
Also,
you cannot necessarily intermix dynamically-allocated
arrays with conventional, statically-allocated ones
(see question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#ary2dfunc3">6.20</a>,
and also question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#pass2dary">6.18</a>).
</p><p>Finally, in C99 you can use a variable-length array.
</p><p>All of
these techniques can also be extended to three or more
dimensions.
Here is a three-dimensional version of the first technique
(which, like the rest of the fragments presented here,
requires error-checking before being used in a real program):
<pre>
	int ***a3d = (int ***)malloc(xdim * sizeof(int **));
	for(i = 0; i &lt; xdim; i++) {
		a3d[i] = (int **)malloc(ydim * sizeof(int *));
		for(j = 0; j &lt; ydim; j++)
			a3d[i][j] = (int *)malloc(zdim * sizeof(int));
	}
</pre>
</p><p>See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#ragged">20.2</a>.
</p>
<p>References:

C9X Sec. 6.5.5.2
<hr><hr><hr>
<a name="non0based">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/non0based.html"><!-- qtag -->Question 6.17</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Here's a neat trick: if I write
<pre>
	int realarray[10];
	int *array = &amp;realarray[-1];
</pre>
I can treat <TT>array</TT> as if it were a 1-based array.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Although this technique is attractive
(and was used in
old editions

of
the book
<I>Numerical Recipes in C</I>),
it is not strictly conforming to the C Standard.
Pointer arithmetic
is defined
only as long as the pointer points
within the same allocated block of memory,
or to the imaginary ``terminating'' element
one past it;
otherwise,
the behavior is undefined,
<em>even if the pointer is not dereferenced</em>.
The code above
computes a pointer to memory before the beginning of <TT>realarray</TT>
and
could fail if,
while subtracting the offset,
an illegal
address were generated
(perhaps because the address tried
to ``wrap around''
past the beginning of some memory segment).


</p><p>Additional links:
<a href="Virginia.html" rel=subdocument>&ldquo;Yes, Virginia&rdquo;</a>
</p>




<p>References:

K&amp;R2 Sec. 5.3 p. 100, Sec. 5.4 pp. 102-3, Sec. A7.7 pp. 205-6
<br>
ISO Sec. 6.3.6
<br>
Rationale Sec. 3.2.2.3
<hr><hr><hr>
<a name="pass2dary">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/pass2dary.html"><!-- qtag -->Question 6.18</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
My compiler complained when I passed a two-dimensional array to a
function expecting a pointer to a pointer.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
The rule
(see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryptrequiv">6.3</a>)
by which arrays decay into pointers is
<em>not</em>
applied recursively.

(Once the rule has been applied once,
the result is a pointer to which the rule no longer applies.)
An array of arrays (i.e. a two-dimensional array in C) decays
into a pointer to an array, not a pointer to a pointer.
Pointers to arrays can be confusing,
and must be treated carefully;
see also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#ptrtoarray">6.13</a>.
</p><p>If you are passing a two-dimensional array to a function:
<pre>
	int array[NROWS][NCOLUMNS];
	f(array);
</pre>
the function's declaration
must match:
<pre>
	void f(int a[][NCOLUMNS])
	{ ... }
</pre>
or
<pre>
	void f(int (*ap)[NCOLUMNS])	/* ap is a pointer to an array */
	{ ... }
</pre>
In the first declaration,

the compiler performs the usual
implicit parameter rewriting
of ``array of array''
to ``pointer to array''
(see questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryptrequiv">6.3</a>
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryptrparam">6.4</a>);
in the second form the pointer declaration is explicit.
Since the called function does not allocate space for the array,
it does not need to know the overall size,
so the number of
rows,

<TT>NROWS</TT>,
can be omitted.
The
width
of the array is still important,
so the
column

dimension
<TT>NCOLUMNS</TT>
(and, for three- or more dimensional arrays,
the intervening ones)
must be
retained.
</p><p>If a function is already declared as accepting a
pointer to a pointer,
it is
almost certainly
meaningless
to pass a two-dimensional array directly to it.
An intermediate pointer would have to be used when attempting to call it
with a two-dimensional array:
<pre>
	extern g(int **ipp);

	int *ip = &amp;array[0][0];
	g(&amp;ip);		/* PROBABLY WRONG */
</pre>
but
this usage is
misleading
and almost certainly
incorrect,
since the array has been ``flattened''
(its shape has been lost).
</p><p>See also questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryvsadr">6.12</a> and <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#dynlocarys">6.15</a>.
</p>


<p>References:

K&amp;R1 Sec. 5.10 p. 110
<br>
K&amp;R2 Sec. 5.9 p. 113
<br>
H&amp;S Sec. 5.4.3 p. 126
<hr><hr><hr>
<a name="ary2dfunc2">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/ary2dfunc2.html"><!-- qtag -->Question 6.19</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How do I write functions which accept two-dimensional arrays
when the width is not known at compile time?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
It's not
always
easy.
One way is to pass in a pointer to the <TT>[0][0]</TT> element, along
with the two dimensions, and simulate array subscripting ``by hand'':
<pre>
	void f2(int *aryp, int nrows, int ncolumns)
	{ ... array[i][j] is accessed as aryp[i * ncolumns + j] ... }
</pre>

Note that the correct expression
for manual subscripting
involves <TT>ncolumns</TT>



(the ``width'' of each row),
not <TT>nrows</TT>
(the <em>number</em> of rows);
it's easy to get this
backwards.

</p><p>This function could be called with the <TT>array</TT> from
question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#pass2dary">6.18</a> 
as
<pre>
	f2(&amp;array[0][0], NROWS, NCOLUMNS);
</pre>
</p><p>It must be noted,
however,
that a program which performs
multidimensional array subscripting ``by hand''
in this way
is not in strict conformance
with the ANSI C Standard;



according to

an official interpretation,
the behavior of accessing
<TT>(&amp;array[0][0])[x]</TT>
is not defined
for <TT>x&nbsp;&gt;=&nbsp;NCOLUMNS</TT>.
</p><p>C99 allows variable-length arrays,
and once compilers which accept C99's extensions become widespread,
VLA's
will probably become the preferred solution.
(<TT>gcc</TT> has supported variable-sized arrays for some time.)
</p><p>When you want to be able to use a function
on multidimensional arrays of various sizes,
one solution is to simulate all the arrays dynamically,
as in question <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#dynmuldimary">6.16</a>.

</p><p>See also questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#pass2dary">6.18</a>,
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#ary2dfunc3">6.20</a>,
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#dynlocarys">6.15</a>.
</p>

<p>References:

ISO Sec. 6.3.6
<br>
C9X Sec. 6.5.5.2
<hr><hr><hr>
<a name="ary2dfunc3">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/ary2dfunc3.html"><!-- qtag -->Question 6.20</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I use statically- and dynamically-allocated
multidimensional arrays interchangeably when passing them to functions?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
There is no single perfect method.
Given the



declarations
<pre>
	int array[NROWS][NCOLUMNS];
	int **array1;			/* ragged */
	int **array2;			/* contiguous */
	int *array3;			/* "flattened" */
	int (*array4)[NCOLUMNS];
<br>	int (*array5)[NROWS][NCOLUMNS];
</pre>
with the pointers
initialized
as
in the code fragments in question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#dynmuldimary">6.16</a>,
and functions declared as


<pre>
	void f1a(int a[][NCOLUMNS], int nrows, int ncolumns);
	void f1b(int (*a)[NCOLUMNS], int nrows, int ncolumns);
	void f2(int *aryp, int nrows, int ncolumns);
	void f3(int **pp, int nrows, int ncolumns);
</pre>
where
<TT>f1a</TT> and <TT>f1b</TT> accept conventional two-dimensional arrays,
<TT>f2</TT> accepts a ``flattened'' two-dimensional array,
and
<TT>f3</TT> accepts a pointer-to-pointer, simulated array
(see also questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#pass2dary">6.18</a> 
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#ary2dfunc2">6.19</a>),
the following calls
should
work as expected:
<pre>
	f1a(array, NROWS, NCOLUMNS);
	f1b(array, NROWS, NCOLUMNS);
	f1a(array4, nrows, NCOLUMNS);
	f1b(array4, nrows, NCOLUMNS);
<br>	f1(*array5, NROWS, NCOLUMNS);
<br>	f2(&amp;array[0][0], NROWS, NCOLUMNS);
	f2(*array, NROWS, NCOLUMNS);
	f2(*array2, nrows, ncolumns);
	f2(array3, nrows, ncolumns);
	f2(*array4, nrows, NCOLUMNS);
<br>	f2(**array5, NROWS, NCOLUMNS);
<br>	f3(array1, nrows, ncolumns);
	f3(array2, nrows, ncolumns);
</pre>
The following
calls would probably work



on most systems,
but involve questionable casts,
and work

only if the dynamic <TT>ncolumns</TT>
matches the static <TT>NCOLUMNS</TT>:
<pre>
	f1a((int (*)[NCOLUMNS])(*array2), nrows, ncolumns);
	f1a((int (*)[NCOLUMNS])(*array2), nrows, ncolumns);
	f1b((int (*)[NCOLUMNS])array3, nrows, ncolumns);
	f1b((int (*)[NCOLUMNS])array3, nrows, ncolumns);
</pre>
</p><p>It will be noticed that only <TT>f2</TT> can conveniently be made to work
with both statically- and dynamically-allocated arrays,
though
it will
<em>not</em>
work with the traditional
``ragged'' array implementation,

<TT>array1</TT>.
However,
it must also
be noted that
passing <TT>&amp;array[0][0]</TT>
(or, equivalently, <TT>*array</TT>)
to <TT>f2</TT>
is not strictly conforming;
see question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#ary2dfunc2">6.19</a>.
</p><p>If you can understand why all of the above calls work and are
written as they are,
and if you understand why the combinations that are not listed
would not work,
then you have a
<em>very</em>
good understanding of arrays and pointers
in C.
</p><p>Rather than worrying about all of this,
one approach to using multidimensional arrays of various sizes
is to make them <em>all</em> dynamic,
as in question <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#dynmuldimary">6.16</a>.
If there are no static multidimensional arrays--if
all arrays are allocated like <TT>array1</TT> or <TT>array2</TT>
in question <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#dynmuldimary">6.16</a>--then
all functions can be written like <TT>f3</TT>.

</p><p>Additional links:
<a href="aryptr.c">Sample source code</a>
(``torture test'')
illustrating all these techniques
<hr><hr><hr>
<a name="aryparmsize">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/aryparmsize.html"><!-- qtag -->Question 6.21</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Why doesn't <TT>sizeof</TT> properly report the size of an array
when the array
is a parameter to a function?
I have a test routine
<pre>
	f(char a[10])
	{
		int i = sizeof(a);
		printf("%d\n", i);
	}
</pre>
and it prints
4, not 10.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
The compiler pretends that the array parameter was declared as a
pointer
(that is,
in the example,
as <TT>char&nbsp;*a</TT>;
see question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#aryptrparam">6.4</a>),
and <TT>sizeof</TT> reports the size of the pointer.
See also questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#extarraysize">1.24</a>
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=malloc#sizeof">7.28</a>.
</p>
<p>References:

H&amp;S Sec. 7.5.2 p. 195
<hr><hr><hr>
<a name="extarysize">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/extarysize.html"><!-- qtag -->Question 6.22</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can code in a file where an array is declared as <TT>extern</TT>
(i.e. it is defined, and its size determined, in some other file)

determine the size of the array?
<TT>sizeof</TT> doesn't seem to work.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#extarraysize">1.24</a>.
<hr><hr><hr>
<a name="arraynels">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/arraynels.html"><!-- qtag -->Question 6.23</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
I want to know how many elements are in an array,
but <TT>sizeof</TT> yields the size in bytes.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Simply divide the size of the entire array by the size of one element:
<pre>
	int array[] = {1, 2, 3};
	int narray = sizeof(array) / sizeof(array[0]);
</pre>

</p>
<p>References:

ISO Sec. 6.3.3.4
<hr><hr><hr>
<a name="arybits">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../aryptr/arybits.html"><!-- qtag -->Question 6.24</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Is there a way to have an array of bits?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
No.
But see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#bitsets">20.8</a>.
<hr><hr><hr>
<hr>
<p>
Read sequentially:
<a href="/~scs/cgi-bin/faqcat.cgi?sec=null" rev=precedes>prev</a>
<a href="/~scs/cgi-bin/faqcat.cgi?sec=malloc" rel=precedes>next</a>
<a href="/~scs/cgi-bin/faqcat.cgi" rev=subdocument>up</a>
</p>
<hr>
<p>
<br><!-- lastfooter -->
<a href="../about.html">about this FAQ list</a>
&nbsp;
<a href="../eskimo.html">about eskimo</a>
&nbsp;
<a href="../search.html">search</a>
&nbsp;
<a href="../feedback.html">feedback</a>
&nbsp;
<a href="copyright.html">copyright</a>
<p>
Hosted by
<a href="http://www.eskimo.com/"><img src="http://www.eskimo.com/img/link/eskitiny.gif" alt="Eskimo North"></a>
</body>
</html>
