<!DOCTYPE HTML PUBLIC "-//W3O//DTD W3 HTML 2.0//EN">
<!-- This collection of hypertext pages is Copyright 1995-2005 by Steve Summit. -->
<!-- Content from the book "C Programming FAQs: Frequently Asked Questions" -->
<!-- (Addison-Wesley, 1995, ISBN 0-201-84519-9) is made available here by -->
<!-- permission of the author and the publisher as a service to the community. -->
<!-- It is intended to complement the use of the published text -->
<!-- and is protected by international copyright laws. -->
<!-- The on-line content may be accessed freely for personal use -->
<!-- but may not be published or retransmitted without explicit permission. -->
<!-- -->
<!-- this page built Sat Dec 24 21:47:47 2005 by faqproc version 2.7 -->
<!-- from source file misc0.sgml dated Sat Nov 24 13:43:27 2001 -->
<!-- corresponding to FAQ list version 4.0 -->
<html>
<head>
<base href="http://c-faq.com/misc/index.html">
<meta name=GENERATOR content="faqproc">
<title>Miscellaneous</title>
</head>
<body bgcolor="#ffffff">
<H1>20. Miscellaneous</H1>
<a name="multretval">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/multretval.html"><!-- qtag -->Question 20.1</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I return
multiple
values from a function?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
There are several ways of doing this.
(These examples show hypothetical
polar-to-rectangular coordinate conversion functions,
which must return both an <TT>x</TT> and a <TT>y</TT> coordinate.)
</p><OL><li>Pass
pointers to
several
locations which the function can fill in:
<pre>
#include &lt;math.h&gt;

polar_to_rectangular(double rho, double theta,
		double *xp, double *yp)
{
	*xp = rho * cos(theta);
	*yp = rho * sin(theta);
}

...

	double x, y;
	polar_to_rectangular(1., 3.14, &amp;x, &amp;y);
</pre>
<li>Have
the function return a structure
containing the desired values:
<pre>
struct xycoord { double x, y; };

struct xycoord
polar_to_rectangular(double rho, double theta)
{
	struct xycoord ret;
	ret.x = rho * cos(theta);
	ret.y = rho * sin(theta);
	return ret;
}

...

	struct xycoord c = polar_to_rectangular(1., 3.14);
</pre>
<li>Use a hybrid:
have the function accept a pointer to a structure,
which it fills in:
<pre>
polar_to_rectangular(double rho, double theta,
		struct xycoord *cp)
{
	cp-&gt;x = rho * cos(theta);
	cp-&gt;y = rho * sin(theta);
}

...

	struct xycoord c;
	polar_to_rectangular(1., 3.14, &amp;c);
</pre>
(Another example of this technique is the Unix system call <TT>stat</TT>.)
<li>In a pinch,
you could theoretically use
global variables
(though this is rarely
a good idea).
</OL><p>See also
questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=struct#firstclass">2.7</a>, <a href="/~scs/cgi-bin/faqcat.cgi?sec=ptrs#passptrinit">4.8</a>, and <a href="/~scs/cgi-bin/faqcat.cgi?sec=malloc#retaggr">7.5a</a>.
<hr><hr><hr>
<a name="ragged">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/ragged.html"><!-- qtag -->Question 20.2</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What's a good data structure to use
for storing lines of text?
I started to use
fixed-size
arrays of arrays of <TT>char</TT>,
but they're just too restrictive.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
One good way of doing this is with a
pointer
(simulating an array)
to a set of pointers
(each simulating an array)
of <TT>char</TT>.
This
data structure
is sometimes called a
``ragged array,''
and looks something like this:
<blockquote>[FIGURE GOES HERE]
</blockquote></p><p>You could set up the tiny array in the figure above with these 
simple declarations:
<pre>
char *a[4] = {"this", "is", "a", "test"};
char **p = a;
</pre>
(where <TT>p</TT> is the pointer-to-pointer-to-<TT>char</TT>
and <TT>a</TT> is an intermediate array used to allocate the four 
pointers-to-<TT>char</TT>).
</p><p>To really do dynamic allocation,
you'd of course have to call <TT>malloc</TT>:
<pre>
#include &lt;stdlib.h&gt;
char **p = malloc(4 * sizeof(char *));
if(p != NULL) {
	p[0] = malloc(5);
	p[1] = malloc(3);
	p[2] = malloc(2);
	p[3] = malloc(5);

	if(p[0] &amp;&amp; p[1] &amp;&amp; p[2] &amp;&amp; p[3]) {
		strcpy(p[0], "this");
		strcpy(p[1], "is");
		strcpy(p[2], "a");
		strcpy(p[3], "test");
	}
}
</pre>
(Some libraries have a <TT>strdup</TT> function
which would streamline the inner
<TT>malloc</TT> and <TT>strcpy</TT> calls.
It's not Standard,
but it's obviously trivial to implement something like it.)
</p><p>Here is a code fragment
which reads an entire file into memory,
using the same kind of ragged array.
This code is written in terms of the
<TT>agetline</TT> function
from question <a href="/~scs/cgi-bin/faqcat.cgi?sec=malloc#reallocnull">7.30</a>.
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
extern char *agetline(FILE *);
FILE *ifp;

/* assume ifp is open on input file */

char **lines = NULL;
size_t nalloc = 0;
size_t nlines = 0;
char *p;

while((p = agetline(ifp)) != NULL) {
	if(nlines &gt;= nalloc) {
		nalloc += 50;
#ifdef SAFEREALLOC
		lines = realloc(lines, nalloc * sizeof(char *));
#else
		if(lines == NULL)		/* in case pre-ANSI realloc */
			lines = malloc(nalloc * sizeof(char *));
		else	lines = realloc(lines, nalloc * sizeof(char *));
#endif
		if(lines == NULL) {
			fprintf(stderr, "out of memory");
			exit(1);
		}
	}

	lines[nlines++] = p;
}
</pre>

(See the comments on reallocation strategy
in question <a href="/~scs/cgi-bin/faqcat.cgi?sec=malloc#reallocnull">7.30</a>.)
</p><p>See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#dynmuldimary">6.16</a>.
<hr><hr><hr>
<a name="argv">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/argv.html"><!-- qtag -->Question 20.3</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I open files mentioned on the command line,
and parse option flags?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Here is a skeleton which implements a traditional Unix-style
<TT>argv</TT> parse,
handling option flags beginning with <TT>-</TT>,
and optional filenames.
(The two flags accepted
by this example
are <TT>-a</TT> and <TT>-b</TT>;
<TT>-b</TT> takes an argument.)
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

main(int argc, char *argv[])
{
	int argi;
	int aflag = 0;
	char *bval = NULL;

	for(argi = 1; argi &lt; argc &amp;&amp; argv[argi][0] == '-'; argi++) {
		char *p;
		for(p = &amp;argv[argi][1]; *p != '\0'; p++) {
			switch(*p) {
			case 'a':
				aflag = 1;
				printf("-a seen\n");
				break;

			case 'b':
				bval = argv[++argi];
				printf("-b seen (\"%s\")\n", bval);
				break;

			default:
				fprintf(stderr,
					"unknown option -%c\n", *p);
			}
		}
	}

	if(argi &gt;= argc) {
		/* no filename arguments; process stdin */
		printf("processing standard input\n");
	} else {
		/* process filename arguments */

		for(; argi &lt; argc; argi++) {
			FILE *ifp = fopen(argv[argi], "r");
			if(ifp == NULL) {
				fprintf(stderr, "can't open %s: %s\n",
					argv[argi], strerror(errno));
				continue;
			}

			printf("processing %s\n", argv[argi]);

			fclose(ifp);
		}
	}

	return 0;
}
</pre>
(This code assumes that <TT>fopen</TT>
sets <TT>errno</TT> when it fails,
which is not guaranteed,
but usually works,
and makes error messages much more useful.
See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#errno">20.4</a>.)
</p><p>There are several canned functions available
for doing command line parsing in a standard way;
the most popular one is
<TT>getopt</TT>
(see also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=resources#sources">18.16</a>).
Here is the above example,
rewritten to use <TT>getopt</TT>:
<pre>
extern char *optarg;
extern int optind;

main(int argc, char *argv[])
{
	int aflag = 0;
	char *bval = NULL;
	int c;

	while((c = getopt(argc, argv, "ab:")) != -1)
		switch(c) {
		case 'a':
			aflag = 1;
			printf("-a seen\n");
			break;

		case 'b':
			bval = optarg;
			printf("-b seen (\"%s\")\n", bval);
			break;
	}

	if(optind &gt;= argc) {
		/* no filename arguments; process stdin */
		printf("processing standard input\n");
	} else {
		/* process filename arguments */

		for(; optind &lt; argc; optind++) {
			FILE *ifp = fopen(argv[optind], "r");
			if(ifp == NULL) {
				fprintf(stderr, "can't open %s: %s\n",
					argv[optind], strerror(errno));
				continue;
			}

			printf("processing %s\n", argv[optind]);

			fclose(ifp);
		}
	}

	return 0;
}
</pre>
</p><p>The examples above overlook a number of nuances:
a lone
``<TT>-</TT>'' is often taken to mean
``read standard input'';
the marker ``<TT>--</TT>'' often signifies the end of the options
(proper versions of <TT>getopt</TT> do handle this);
it's traditional to print a usage message
when a command is invoked with improper or missing arguments.
</p><p>If you're wondering how <TT>argv</TT> is laid out in memory,
it's actually a
``ragged array'';
see the picture in
question <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#ragged">20.2</a>.
See also questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=charstring#stringeq">8.2</a>,
<a href="/~scs/cgi-bin/faqcat.cgi?sec=lib#regex">13.7</a>,
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#readdir">19.20</a>.
</p>








<p>References:

K&amp;R1 Sec. 5.11 pp. 110-114
<br>
K&amp;R2 Sec. 5.10 pp. 114-118
<br>
ISO Sec. 5.1.2.2.1
<br>
H&amp;S Sec. 20.1 p. 416
<br>
PCS Sec. 5.6 pp. 81-2, Sec. 11 p. 159, pp. 339-40 Appendix F
<br>
Schumacher, ed.,
<I>Software Solutions in C</I> Sec. 4 pp. 75-85
<hr><hr><hr>
<a name="errno">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/errno.html"><!-- qtag -->Question 20.4</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What's the right way
to use <TT>errno</TT>?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
In general,
you should detect errors by checking return values,
and use <TT>errno</TT> only to distinguish among the various 
causes of an error,
such as ``File not found''
or ``Permission denied''.
(Typically, you use
<TT>perror</TT> or
<TT>strerror</TT>
to print these
discriminating
error messages.)
It's only necessary to detect errors with <TT>errno</TT>
when a function does not have a unique, unambiguous,
out-of-band
error return
(i.e. because all of its possible return values are valid;
one example is <TT>atoi</TT>).
In these cases
(and in these cases only;
check the documentation
to be sure
whether

a function allows this),
you can detect errors by setting <TT>errno</TT> to 0,
calling the function,
then testing <TT>errno</TT>.
(Setting <TT>errno</TT> to 0 first is important,
as
no library function ever does
that for you.)
</p><p>To make error messages useful,
they should include all relevant information.
Besides the <TT>strerror</TT>
text derived from <TT>errno</TT>,
it may also be appropriate to print the name of the program,
the operation which failed
(preferably in terms which will be meaningful to the user),
the name of the file for which the operation failed,
and,
if some input file
(script or source file)
is being read,
the name and
current
line number of that file.
</p><p>See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=stdio#printferrno">12.24</a>.
</p>






<p>References:

ISO Sec. 7.1.4, Sec. 7.9.10.4, Sec. 7.11.6.2
<br>
CT&amp;P Sec. 5.4 p. 73
<br>
PCS Sec. 11 p. 168, Sec. 14 p. 254
<hr><hr><hr>
<a name="binaryfiles">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/binaryfiles.html"><!-- qtag -->Question 20.5</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I write data files which can be read on other machines
with different
word size,
byte order,
or floating point
formats?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
The
most portable
solution is to use
text files
(usually ASCII),
written with <TT>fprintf</TT> and read with <TT>fscanf</TT> or the like.
(Similar advice also applies to network protocols.)
Be skeptical of arguments which imply that text
files are too big,
or that reading and writing them is too slow.

Not only is their efficiency frequently acceptable in practice,

but the advantages
of being able to
interchange them easily between machines,
and
manipulate them with standard
tools,
can be overwhelming.

</p><p>If you must use a binary format,
you can improve portability,
and perhaps take advantage of prewritten I/O libraries,
by making use of standardized formats such as
Sun's XDR (RFC 1014),

OSI's ASN.1
(referenced in CCITT X.409
and ISO&nbsp;8825
``Basic Encoding Rules''),
CDF, netCDF, or HDF.




See also
questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=struct#padding">2.12</a>, <a href="/~scs/cgi-bin/faqcat.cgi?sec=stdio#fopenbinary">12.38</a>, and <a href="/~scs/cgi-bin/faqcat.cgi?sec=stdio#extconform">12.42</a>.
</p>
<p>References:

PCS Sec. 6 pp. 86, 88
<hr><hr><hr>
<a name="symtab">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/symtab.html"><!-- qtag -->Question 20.6</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
If I have a <TT>char&nbsp;*</TT> variable
pointing to
the name of a function,
how can I call that function?
Code like
<pre>
	extern int func(int, int);
	char *funcname = "func";
	int r = (*funcname)(1, 2);
</pre>
or
<pre>
	r = (*(int (*)(int, int))funcname)(1, 2);
</pre>
doesn't seem to work.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>



By the time a program is running, information about
the names of its functions and variables
(the
``symbol table'') is no longer
needed,
and may therefore not be
available.

The most straightforward thing to do,
therefore,

is
to maintain
that information yourself,
with
a correspondence
table of names and function pointers:
<pre>
int one_func(), two_func();
int red_func(), blue_func();

struct { char *name; int (*funcptr)(); } symtab[] = {
	"one_func",	one_func,
	"two_func",	two_func,
	"red_func",	red_func,
	"blue_func",	blue_func,
};
</pre>
Then,
search the table for the name, and call
via

the
associated function pointer,
with code like this:
<pre>
#include &lt;stddef.h&gt;

int (*findfunc(char *name))()
{
	int i;

	for(i = 0; i &lt; sizeof(symtab) / sizeof(symtab[0]); i++) {
		if(strcmp(name, symtab[i].name) == 0)
			return symtab[i].funcptr;
		}

	return NULL;
}

...

	char *funcname = "one_func";
	int (*funcp)() = findfunc(funcname);
	if(funcp != NULL)
		(*funcp)();
</pre>



The callable

functions should all have
compatible argument and return types.
(Ideally,
the function pointers would also specify the argument types.)
</p><p>It is
sometimes possible
for a program to read its own symbol table



if it is still present,
but it must first be able to find its own executable
(see question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#exepath">19.31</a>),
and it must know how to interpret the symbol table
(some
Unix
C libraries provide
an <TT>nlist</TT> function for this purpose).
See also questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=struct#fieldnames">2.15</a>,
<a href="/~scs/cgi-bin/faqcat.cgi?sec=resources#expreval">18.14</a>,
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#dynlink">19.36</a>.
</p>
<p>References:

PCS Sec. 11 p. 168
<hr><hr><hr>
<a name="intovf">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/intovf.html"><!-- qtag -->Question 20.6b</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I ensure that integer arithmetic doesn't overflow?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
The usual approach is to test
the operands against the limits in
the header file <TT>&lt;limits.h&gt;</TT>
before doing the operation.
For example, here is a ``careful'' addition function:
<pre>
int
chkadd(int a, int b)
{
	if(INT_MAX - b &lt; a) {
		fputs("int overflow\n", stderr);
		return INT_MAX;
	}
	return a + b;
}
</pre>
See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep#fpexcepts">19.39</a>.
</p><p>Additional links:
<a href="sd26.html" rel=subdocument>more sample code</a>
<hr><hr><hr>
<a name="bitmanip">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/bitmanip.html"><!-- qtag -->Question 20.7</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I manipulate individual bits?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Bit manipulation is
straightforward
in C,
and commonly done.
To extract
(test)
a bit,
use the bitwise AND (<TT>&amp;</TT>)
operator,
along with a bit mask
representing the bit(s) you're interested in:
<pre>
	value &amp; 0x04
</pre>
To set a bit,
use the bitwise OR (<TT>|</TT> or <TT>|=</TT>) operator:
<pre>
	value |= 0x04
</pre>
To clear a bit,
use the bitwise complement (<TT>~</TT>)
and the AND (<TT>&amp;</TT> or <TT>&amp;=</TT>) operators:
<pre>
	value &amp;= ~0x04
</pre>
(The preceding three examples all manipulate
the third-least significant,
or
2**2,
bit,
expressed as the constant bitmask <TT>0x04</TT>.)
</p><p>To manipulate an arbitrary bit, use the shift-left operator
(<TT>&lt;&lt;</TT>) to generate the mask you need:
<pre>
	value &amp; (1 &lt;&lt; bitnumber)
	value |= (1 &lt;&lt; bitnumber)
	value &amp;= ~(1 &lt;&lt; bitnumber)
</pre>
Alternatively,
you may wish to precompute
an array of masks:
<pre>
	unsigned int masks[] =
		{0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};

	value &amp; masks[bitnumber]
	value |= masks[bitnumber]
	value &amp;= ~masks[bitnumber]
</pre>
</p><p>


To avoid surprises involving the sign bit,
it is often a good idea to use unsigned integral types
in code
which manipulates
bits and bytes.
</p><p>See also questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=bool#bool2">9.2</a> and <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#bitsets">20.8</a>.
</p>









<p>References:

K&amp;R1 Sec. 2.9 pp. 44-45
<br>
K&amp;R2 Sec. 2.9 pp. 48-49
<br>
ISO Sec. 6.3.3.3, Sec. 6.3.7, Sec. 6.3.10, Sec. 6.3.12
<br>
H&amp;S Sec. 7.5.5 p. 197, Sec. 7.6.3 pp. 205-6, Sec. 7.6.6 p. 210
<hr><hr><hr>
<a name="bitsets">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/bitsets.html"><!-- qtag -->Question 20.8</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I implement sets or arrays of bits?

</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Use arrays of <TT>char</TT> or <TT>int</TT>,
with a few macros to access the desired bit
in the proper cell of the array.
Here are some simple macros to use with arrays of <TT>char</TT>:
<pre>
#include &lt;limits.h&gt;		/* for CHAR_BIT */

#define BITMASK(b) (1 &lt;&lt; ((b) % CHAR_BIT))
#define BITSLOT(b) ((b) / CHAR_BIT)
#define BITSET(a, b) ((a)[BITSLOT(b)] |= BITMASK(b))
#define BITCLEAR(a, b) ((a)[BITSLOT(b)] &amp;= ~BITMASK(b))
#define BITTEST(a, b) ((a)[BITSLOT(b)] &amp; BITMASK(b))
#define BITNSLOTS(nb) ((nb + CHAR_BIT - 1) / CHAR_BIT)
</pre>
(If you don't have <TT>&lt;limits.h&gt;</TT>,
try using 8 for <TT>CHAR_BIT</TT>.)
</p><p>Here are some usage examples.
To declare an ``array'' of 47 bits:
<pre>
	char bitarray[BITNSLOTS(47)];
</pre>
To set the
23rd
bit:
<pre>
	BITSET(bitarray, 23);
</pre>
To test the
35th
bit:
<pre>
	if(BITTEST(bitarray, 35)) ...
</pre>
To
compute the
union of two bit arrays
and place it in a third array
(with all three arrays declared as above):
<pre>
	for(i = 0; i &lt; BITNSLOTS(47); i++)
		array3[i] = array1[i] | array2[i];
</pre>
To compute the intersection, use <TT>&amp;</TT> instead of <TT>|</TT>.
</p><p>As a more realistic example,
here is a quick implementation of the Sieve of Eratosthenes,
for computing
prime numbers:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAX 10000

int main()
{
	char bitarray[BITNSLOTS(MAX)];
	int i, j;

	memset(bitarray, 0, BITNSLOTS(MAX));

	for(i = 2; i &lt; MAX; i++) {
		if(!BITTEST(bitarray, i)) {
			printf("%d\n", i);
			for(j = i + i; j &lt; MAX; j += i)
				BITSET(bitarray, j);
		}
	}
	return 0;
}
</pre>
</p><p>See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#bitmanip">20.7</a>.
</p><p>Additional links:




<a href="bitsets.970425.html">further explanation</a>
</p>
<p>References:

H&amp;S Sec. 7.6.7 pp. 211-216
<hr><hr><hr>
<a name="endiantest">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/endiantest.html"><!-- qtag -->Question 20.9</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I determine whether a machine's
byte order
is big-endian or little-endian?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
The usual techniques are
to use a pointer:
<pre>
	int x = 1;
	if(*(char *)&amp;x == 1)
		printf("little-endian\n");
	else	printf("big-endian\n");
</pre>
or a union:
<pre>
	union {
		int i;
		char c[sizeof(int)];
	} x;
	x.i = 1;
	if(x.c[0] == 1)
		printf("little-endian\n");
	else	printf("big-endian\n");
</pre>
</p><p>




(Note that there are also byte order possibilities beyond simple
big-endian and little-endian<a href="fn96.html" rel=subdocument>[footnote]</a>
.)
</p><p>See also questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=cpp#ifendian">10.16</a>
and <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#byteswap">20.9b</a>.
</p>
<p>References:

H&amp;S Sec. 6.1.2 pp. 163-4
<hr><hr><hr>
<a name="byteswap">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/byteswap.html"><!-- qtag -->Question 20.9b</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How do I swap bytes?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
V7 Unix had a <TT>swab</TT> function,
but it seems to have been forgotten.
</p><p>A problem with
explicit byte-swapping code
is that you have
to decide whether to call it or not,
based on the byte order of the data
and the byte order of the machine in use.
Question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#endiantest">20.9</a>
shows how, but it's a nuisance.
</p><p>A better solution is to
define functions
which convert between the known byte order of the data
and the (unknown) byte order of the machine
in use,
and to arrange for these functions to be no-ops
on those machines which already match the desired byte order.
A set of such functions,
introduced with the BSD networking code but now in wide use,
is <TT>ntohs</TT>, <TT>htons</TT>, <TT>ntohl</TT>, and <TT>htonl</TT>.
These are intended to convert between
``network'' and ``host'' byte orders,
for ``short'' or ``long'' integers,
where ``network'' order is always big-endian,
and where ``short'' integers are always 16 bits
and ``long'' integers are 32 bits.
(This is not the C definition, of course,
but it's compatible with the C definition;
see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#inttypes">1.1</a>.)
So if you know that the data you want to convert from or to is big-endian,
you can use these functions.
(The point is that you <em>always</em> call the functions,
making your code much cleaner.
Each function either swaps bytes if it has to, or does nothing.
The decision to swap or not to swap gets made once,
when the functions are implemented for a particular machine,
rather than being made many times in many different calling programs.)
</p><p>If you do have to write your own byte-swapping code,
the two obvious approaches are again to use pointers or unions,
as in question <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#endiantest">20.9</a>.
Here is an example using pointers:
<pre>
void byteswap(char *ptr, int nwords)
{
	char *p = ptr;
	while(nwords-- &gt; 0) {
		char tmp = *p;
		*p = *(p + 1);
		*(p + 1) = tmp;
		p += 2;
	}
}
</pre>
</p><p>And here is one using unions:
<pre>
union word
	{
	short int word;
	char halves[2];
	};

void byteswap(char *ptr, int nwords)
{
	register union word *wp = (union word *)ptr;
	while(nwords-- &gt; 0) {
		char tmp = wp-&gt;halves[0];
		wp-&gt;halves[0] = wp-&gt;halves[1];
		wp-&gt;halves[1] = tmp;
		wp++;
	}
}
</pre>
</p><p>These functions swap two-byte quantities;
the extension to four
or more
bytes should be obvious.
The union-using code is imperfect
in that it assumes that the passed-in pointer is word-aligned.
It would also be possible to write functions
accepting separate source and destination pointers,
or accepting single words and returning the swapped values.
</p>
<p>References:

PCS Sec. 11 p. 179
<hr><hr><hr>
<a name="hexio">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/hexio.html"><!-- qtag -->Question 20.10</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I convert integers to
binary or
hexadecimal?

</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Make sure you really know what you're asking.
Integers are stored internally in binary,
although for most purposes it is not incorrect
to think of them as being in
octal, decimal, or hexadecimal,
whichever is convenient.
The base in which a number is expressed matters only when that
number is read in from or written out to the outside world,
either in the form of
a source code constant
or in the form of I/O
performed by a program.
</p><p>In source code,
a non-decimal base is indicated
by
a leading <TT>0</TT> or <TT>0x</TT>
(for octal or hexadecimal, respectively).
During I/O, the base of a formatted number is controlled
in the
<TT>printf</TT>
and <TT>scanf</TT>
family
of functions
by the choice of format specifier
(<TT>%d</TT>, <TT>%o</TT>, <TT>%x</TT>, etc.)
and in the <TT>strtol</TT>
and <TT>strtoul</TT>
functions
by the third argument.
During
<em>binary</em> I/O,
however, the base again becomes immaterial:

if numbers are being read or written as individual bytes
(typically with <TT>getc</TT> or <TT>putc</TT>),
or as multi-byte words
(typically with <TT>fread</TT> or <TT>fwrite</TT>),
it is meaningless to ask what ``base'' they are in.
</p><p>If what you need is formatted binary conversion,
it's easy enough to do.
Here is a little function
for formatting
a number in a requested base:


<pre>
char *
baseconv(unsigned int num, int base)
{
	static char retbuf[33];
	char *p;

	if(base &lt; 2 || base &gt; 16)
		return NULL;

	p = &amp;retbuf[sizeof(retbuf)-1];
	*p = '\0';

	do {
		*--p = "0123456789abcdef"[num % base];
		num /= base;
	} while(num != 0);

	return p;
}
</pre>

(Note that this function, as written,
returns a pointer to static data,
such that only one of its return values can be used at a time;
see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=malloc#retaggr">7.5a</a>.
A better size for the <TT>retbuf</TT> array
would be <TT>sizeof(int)*CHAR_BIT+1</TT>;
see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=stdio#sprintfsize">12.21</a>.)
</p><p>For more information about ``binary'' I/O,
see
questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=struct#io">2.11</a>, <a href="/~scs/cgi-bin/faqcat.cgi?sec=stdio#binaryio">12.37</a>, and <a href="/~scs/cgi-bin/faqcat.cgi?sec=stdio#extconform">12.42</a>.
See also questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=charstring#asciivals">8.6</a>
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=lib#itoa">13.1</a>.
</p><p>Additional links:
A
<a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#btod">long reply</a>
I sent to someone who was asking how to write a
``binary to decimal'' conversion function
</p>

<p>References:

ISO Secs. 7.10.1.5,7.10.1.6
<hr><hr><hr>
<a name="base2">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/base2.html"><!-- qtag -->Question 20.11</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Can I use base-2 constants
(something like <TT>0b101010</TT>)?
<br>Is there a
<TT>printf</TT> format for binary?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
No, on both counts,
although there are various preprocessor tricks you can try
(see the links below).
You can convert base-2 string representations
to integers with <TT>strtol</TT>.
If you need to print numbers out in base 2,
see
the example code in
question <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#hexio">20.10</a>.
</p><p>Additional links:
<br>
<br>
<a href="http://home.att.net/~jackklein/ctips01.html#binary_in">example by Jack Klein</a>
<br>
<br>



<a href="sd27.html" rel=subdocument>preprocessor trick</a>
by Karl Heuer
<br>
<br>
<a href="sd28.html" rel=subdocument>prettier preprocessor trick</a>
by Bill Finke
<hr><hr><hr>
<a name="bitcount">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/bitcount.html"><!-- qtag -->Question 20.12</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What is the most efficient way to count the number of bits
which are set in
an integer?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Many ``bit-fiddling'' problems
like this one
can be
sped up and streamlined using
lookup tables
(but see
question <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#efficiency">20.13</a>).
Here is a little function which computes the number of bits in a value,
4 bits at a time:
<pre>
static int bitcounts[] =
	{0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4};

int bitcount(unsigned int u)
{
	int n = 0;

	for(; u != 0; u &gt;&gt;= 4)
		n += bitcounts[u &amp; 0x0f];

	return n;
}
</pre>
<hr><hr><hr>
<a name="efficiency">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/efficiency.html"><!-- qtag -->Question 20.13</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What's the best way of making my program efficient?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
By picking good algorithms,
implementing them carefully,
and making sure that your program isn't doing any extra work.
For example,
the most microoptimized character-copying loop in the world
will be beat by code which avoids having to copy characters at all.
</p><p>When worrying about efficiency,
it's important to keep several things in perspective.
First of all,
although efficiency is
an enormously popular
topic,
it
is not
always as important
as people tend to think it is.
Most of the code in most programs is not time-critical.
When code is not time-critical,
it is
usually
more important that it be written clearly and portably
than that it be written maximally efficiently.
(Remember that
computers are very, very fast,
and that seemingly ``inefficient'' code
may be quite efficiently compilable,
and
run without apparent delay.)
</p><p>It is notoriously difficult to predict
what
the ``hot spots'' in a program will be.
When efficiency is a concern,
it is important to use profiling software
to determine which parts of the program deserve attention.
Often, actual computation time is swamped by peripheral tasks
such as I/O and memory allocation,
which can be sped up by using buffering and caching
techniques.
</p><p>Even
for
code that <em>is</em> time-critical,
one of the least effective optimization techniques
is to fuss with
the coding details.
Many of the ``efficient coding tricks''
which are frequently suggested
are performed automatically
by even
simpleminded
compilers.
Heavyhanded optimization attempts can make code so
bulky that performance is actually degraded,
by increasing the number of page faults or
by
overflowing 
instruction caches or pipelines.
Furthermore,
optimization tricks
are rarely portable
(i.e. they may speed things up on one machine
but slow them down on another).
In any case,
tweaking the coding usually results in
at best linear performance improvements;
the big payoffs are in better
algorithms.
</p><p>If the performance of your code is so important
that you are willing to invest programming time
in source-level optimizations,
make sure that you are using
the best optimizing compiler
you can afford.
(Compilers,
even mediocre ones,
can perform optimizations
that are impossible at the source level).
</p><p>When efficiency is truly
important,
the best algorithm has been chosen,
and even the coding details matter,
the following suggestions may be useful.
(These are mentioned merely
to keep followups down;
appearance here does
<em>not</em>
necessarily
constitute endorsement by the author.
Note that several of these techniques
cut both ways,
and
may make things worse.)
<OL><li>Sprinkle the code liberally with <TT>register</TT> declarations for
oft-used variables;
place them in inner blocks,
if applicable.
(On the other hand, most modern compilers ignore <TT>register</TT>
declarations, on the assumption that they can perform register 
analysis and assignment better than the programmer can.)
<li>Check the algorithm carefully.
Exploit symmetries where possible to reduce the number of explicit cases.
<li>Examine the control flow:
make sure that common cases are checked for first,
and handled more easily.
If one side of
an expression involving <TT>&amp;&amp;</TT> or <TT>||</TT>
will usually determine the outcome,

make it the left-hand side,
if possible.
(See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=expr#shortcircuit">3.6</a>.)
<li>Use <TT>memcpy</TT> instead of
<TT>memmove</TT>,
if appropriate
(see question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=ansi#memmove">11.25</a>).
<li>Use machine- and vendor-specific routines and <TT>#pragma</TT>s.
<li>Manually place
common subexpressions
in temporary variables.
(Good compilers do this for you.)
<li>Move critical, inner-loop code
out of functions
and into macros or in-line functions
(and out of the loop, if invariant).
If the termination condition of a loop is a complex
but loop-invariant
expression,
precompute it and place it in a temporary variable.
(Good compilers do these for you.)
<li>


Change recursion to iteration, if possible.
<li>Unroll small loops.

<li>Discover whether
<TT>while</TT>, <TT>for</TT>,
or <TT>do/while</TT>
loops produce the best code under your compiler,
and whether incrementing or decrementing
the loop control variable
works best.
<li>Remove <TT>goto</TT> statements--some compilers can't optimize 
as well in their presence.
<li>Use pointers rather than array subscripts to step through arrays
(but see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#eff2">20.14</a>).
<li>Reduce precision.
(Using <TT>float</TT> instead of <TT>double</TT>
may result in faster,
single-precision arithmetic under an ANSI compiler,
though
older compilers convert everything to <TT>double</TT>,
so using <TT>float</TT> can also be slower.)
Replace time-consuming trigonometric and logarithmic functions
with your own,
tailored to the range and precision you need,
and perhaps using table lookup.
(Be sure to give your versions
<em>different</em>
names;
see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#namespace">1.29</a>.)
<li>Cache or precompute
tables of frequently-needed values.
(See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#bitcount">20.12</a>.)
<li>


Use standard library functions in preference to your own.
(Sometimes the compiler
inlines or
specially optimizes
its own functions.)
On the other hand,
if your program's calling patterns are
particularly regular,
your own special-purpose implementation may be able to beat
the library's general-purpose version.
(Again, if you do write your own version,
give it a different name.)
<li>As a last,
<em>last</em>
resort, hand-code critical routines in assembly language
(or hand-tune the compiler's assembly language output).
Use <TT>asm</TT> directives, if possible.
</OL></p><p>Here are some things <em>not</em> to worry about:
<OL><li>17x.
whether <TT>i++</TT> is faster than <TT>i&nbsp;=&nbsp;i&nbsp;+&nbsp;1</TT>
<li>18x.
whether <TT>i&nbsp;&lt;&lt;&nbsp;1</TT>
(or <TT>i&nbsp;&gt;&gt;&nbsp;1</TT>, or <TT>i&nbsp;&amp;&nbsp;1</TT>)
is faster than <TT>i&nbsp;*&nbsp;2</TT>
(respectively <TT>i&nbsp;/&nbsp;2</TT>, <TT>i&nbsp;%&nbsp;2</TT>).
</OL></p><p>(These are examples of optimizations which compilers regularly 
perform for you;
see questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#eff2">20.14</a>
and <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#shifts">20.15</a>.)
</p><p>It is not the intent here to suggest that efficiency can be
completely ignored.
Most of the time,
however,
by simply paying attention to good algorithm choices,
implementing them
cleanly,
and avoiding obviously inefficient blunders
(i.e. make sure you don't end up with an
O(n**3)
implementation of an
O(n**2)
algorithm),

perfectly acceptable results can be achieved.
</p><p>For more discussion of efficiency tradeoffs,
as well as good advice on how to improve efficiency when it is important,
see
chapter 7 of Kernighan and Plauger's
<I>The Elements of Programming Style</I>,
and Jon Bentley's
<I>Writing Efficient Programs</I>.
</p><p>See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=style#vsefficiency">17.11</a>.
<hr><hr><hr>
<a name="eff2">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/eff2.html"><!-- qtag -->Question 20.14</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Are pointers really faster than arrays?
How much do function calls slow things down?
Is <TT>++i</TT> faster than <TT>i&nbsp;=&nbsp;i&nbsp;+&nbsp;1</TT>?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Precise answers to these and many similar questions
depend
of course
on the processor and compiler in use.
If you simply must know,
you'll have to time test programs carefully.
(Often the differences are so slight that
hundreds of
thousands of iterations are required even to see them.
<a href="subtle.html" rel=subdocument>[footnote]</a>
Check the compiler's assembly language output,
if available,
to see if two
purported alternatives aren't compiled identically.)
</p><p>For conventional machines,
it is usually
faster to march through large arrays with
pointers rather than array subscripts,
but for some processors the reverse is true.
(Better compilers should
generate good code
regardless of which notation you use,
though





it's arguably easier for a compiler
to convert array indices to pointers than vice versa<a href="fn98.html" rel=subdocument>[footnote]</a>
.)
</p><p>Function calls,
though obviously incrementally slower than in-line code,
contribute so much to modularity and code clarity
that there is rarely good reason to avoid them.
(Actually, by reducing bulk,
functions can improve performance.)
Also,



some compilers are able to expand
small, critical-path functions
in-line,
either as an optimization or at the programmer's request.
</p><p>Before rearranging expressions such as <TT>i&nbsp;=&nbsp;i&nbsp;+&nbsp;1</TT>,
remember that you are dealing with a compiler,
not a keystroke-programmable calculator.
Any decent compiler
will generate identical code for <TT>++i</TT>, <TT>i&nbsp;+=&nbsp;1</TT>,
and <TT>i&nbsp;=&nbsp;i&nbsp;+&nbsp;1</TT>.
The reasons for using <TT>++i</TT> or <TT>i&nbsp;+=&nbsp;1</TT> over <TT>i&nbsp;=&nbsp;i&nbsp;+&nbsp;1</TT>
have to do with style, not efficiency.
(See also question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=expr#plusplus">3.12b</a>.)
<hr><hr><hr>
<a name="shifts">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/shifts.html"><!-- qtag -->Question 20.15</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
I've been replacing multiplications and divisions
with shift operators,
because shifting is more efficient.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
This is an excellent example of a potentially risky
and usually unnecessary optimization.
Any compiler worthy of the name can replace a
constant, power-of-two
multiplication with a left shift,
or a
similar
division of an unsigned quantity with a right shift.
(Ritchie's original PDP-11 compiler,
though it ran in less than 64K of memory
and omitted several features now considered mandatory,
performed both of these optimizations,
without even
turning on its optional optimization pass.)

Furthermore,
a compiler will make these optimizations only when they're correct;
many programmers overlook the fact
that shifting a negative value
to the
right
is <em>not</em> equivalent to division.
(Therefore,
when you need to make sure that these optimizations are performed,
you may have to declare relevant variables as <TT>unsigned</TT>.)
<hr><hr><hr>
<a name="unsshift">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/unsshift.html"><!-- qtag -->Question 20.15b</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
People claim that optimizing compilers are good
and that we no longer have to write things in assembler for speed,
but
my compiler
can't even
replace <TT>i/=2</TT> with a shift.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Was <TT>i</TT> signed or unsigned?
If it was signed,
a shift is not equivalent
(hint: think about the result if <TT>i</TT> is negative and odd),
so the compiler was correct not to use it.
<hr><hr><hr>
<a name="swapnotemp">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/swapnotemp.html"><!-- qtag -->Question 20.15c</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I swap two values without using a temporary?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
The
standard hoary old assembly language programmer's
trick is:
<pre>
a ^= b;
b ^= a;
a ^= b;
</pre>
But this sort of code has little place in modern,
HLL programming.
Temporary variables are essentially free,
and the idiomatic code using three assignments,
namely
<pre>
	int t = a;
	a = b;
	b = t;
</pre>
is not only clearer to the human reader,
it is more likely to be recognized by the compiler
and turned into the most-efficient code
(e.g. perhaps even using an EXCH instruction).
The latter code is obviously also amenable
to use with pointers and floating-point values,
unlike the XOR trick.
See
also questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=expr#xorswapexpr">3.3b</a> and <a href="/~scs/cgi-bin/faqcat.cgi?sec=cpp#swapmacro">10.3</a>.
</p><p>Additional links:



<a href="swap.homework.html">further reading</a>
<hr><hr><hr>
<a name="switchimpl">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/switchimpl.html"><!-- qtag -->Question 20.16</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Which is more efficient,
a <TT>switch</TT> statement or an <TT>if</TT>/<TT>else</TT> chain?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
The differences,
if any,
are likely to be slight.

The <TT>switch</TT> statement was designed to be efficiently implementable,

though the compiler may
choose to
use the equivalent of an if/else chain
(as opposed to a
compact

jump table)
if the case labels are sparsely distributed.

</p><p>Do use <TT>switch</TT> when you can:
it's certainly cleaner,
and perhaps more efficient
(and certainly
should never be
any <em>less</em> efficient).
</p><p>See also questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#strswitch">20.17</a>
and <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#nonconstcase">20.18</a>.
<hr><hr><hr>
<a name="strswitch">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/strswitch.html"><!-- qtag -->Question 20.17</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Is there a way to <TT>switch</TT> on strings?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Not directly.
Sometimes, it's appropriate
to use a separate function to map strings to integer codes,
and then switch on those:
<pre>
#define CODE_APPLE	1
#define CODE_ORANGE	2
#define CODE_NONE	0

switch(classifyfunc(string)) {
	case CODE_APPLE:
		...

	case CODE_ORANGE:
		...

	case CODE_NONE:
		...
}
</pre>
where <TT>classifyfunc</TT> looks something like
<pre>
static struct lookuptab {
	char *string;
	int code;
} tab[] = {
	{"apple",	CODE_APPLE},
	{"orange",	CODE_ORANGE},
};

classifyfunc(char *string)
{
	int i;
	for(i = 0; i &lt; sizeof(tab) / sizeof(tab[0]); i++)
		if(strcmp(tab[i].string, string) == 0)
			return tab[i].code;

	return CODE_NONE;
}
</pre>

</p><p>Otherwise, of course,
you can fall back on

a conventional <TT>if</TT>/<TT>else</TT> chain:
<pre>
	if(strcmp(string, "apple") == 0) {
		...
	} else if(strcmp(string, "orange") == 0) {
		...
	}
</pre>
(A macro like
<TT>Streq()</TT>
from question <a href="/~scs/cgi-bin/faqcat.cgi?sec=style#strcmp">17.3</a>
can make these comparisons a bit more convenient.)
</p><p>See also
questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=cpp#ifstrcmp">10.12</a>, <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#switchimpl">20.16</a>, <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#nonconstcase">20.18</a>, and <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#hash">20.29</a>.
</p>




<p>References:

K&amp;R1 Sec. 3.4 p. 55
<br>
K&amp;R2 Sec. 3.4 p. 58
<br>
ISO Sec. 6.6.4.2
<br>
H&amp;S Sec. 8.7 p. 248
<hr><hr><hr>
<a name="nonconstcase">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/nonconstcase.html"><!-- qtag -->Question 20.18</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Is there a way to have non-constant <TT>case</TT> labels
(i.e. ranges or arbitrary expressions)?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
No.
The <TT>switch</TT> statement
was originally designed to be quite simple for the compiler to translate,
therefore case labels are limited to single, constant, integral expressions.
You <em>can</em> attach several case labels to the same statement,
which will let you cover a small range if you don't mind 
listing all cases explicitly.
</p><p>If you want to select on arbitrary ranges
or non-constant expressions,
you'll have to use an <TT>if</TT>/<TT>else</TT> chain.
</p><p>See also
questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#switchimpl">20.16</a> and <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#strswitch">20.17</a>.
</p>




<p>References:

K&amp;R1 Sec. 3.4 p. 55
<br>
K&amp;R2 Sec. 3.4 p. 58
<br>
ISO Sec. 6.6.4.2
<br>
Rationale Sec. 3.6.4.2
<br>
H&amp;S Sec. 8.7 p. 248
<hr><hr><hr>
<a name="returnparens">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/returnparens.html"><!-- qtag -->Question 20.19</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Are the outer parentheses
in <TT>return</TT> statements
really optional?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Yes.
</p><p>Long ago,
in the early days of C,
they were required,
and just enough people learned C then,
and wrote code which is still in circulation,
that the
notion
that
they might still be required
is
widespread.
</p><p>(As it happens,
parentheses are optional with the
<TT>sizeof</TT>
operator, too,
under certain circumstances.)
</p>



<p>References:

K&amp;R1 Sec. A18.3 p. 218
<br>
ISO Sec. 6.3.3, Sec. 6.6.6
<br>
H&amp;S Sec. 8.9 p. 254
<hr><hr><hr>
<a name="nestcomment">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/nestcomment.html"><!-- qtag -->Question 20.20</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Why don't C comments nest?
How am I supposed to comment out code containing comments?
Are
comments
legal inside quoted strings?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
C comments don't nest
mostly
because PL/I's comments,
which C's are borrowed from,
don't either.
Therefore,
it is usually better to ``comment out''
large sections of code, which might contain comments, with
<TT>#ifdef</TT> or <TT>#if 0</TT>
(but see question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=ansi#ifdefsyntax">11.19</a>).
</p><p>The character sequences <TT>/*</TT> and <TT>*/</TT> are
not special within double-quoted
strings,
and do not therefore introduce comments,
because a program
(particularly one which is generating C code as output)
might want to print them.
(It is hard to imagine why anyone would want or need to place a
comment inside a quoted string.
It is easy to imagine a program needing to print "<TT>/*</TT>".)
</p><p>Note also that <TT>//</TT> comments
have only become legal in C as of C99.
</p>








<p>References:

K&amp;R1 Sec. A2.1 p. 179
<br>
K&amp;R2 Sec. A2.2 p. 192
<br>
ISO Sec. 6.1.9, Annex F
<br>
Rationale Sec. 3.1.9
<br>
H&amp;S Sec. 2.2 pp. 18-9
<br>
PCS Sec. 10 p. 130
<hr><hr><hr>
<a name="multibreak">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/multibreak.html"><!-- qtag -->Question 20.20b</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Why isn't there a numbered, multi-level <TT>break</TT> statement
to break out of several loops at once?
What am I supposed to use instead, a <TT>goto</TT>?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
First, remember why it is that <TT>break</TT> and <TT>continue</TT>
exist at all--they are,
in effect, ``structured <TT>goto</TT>s''
used in preference to <TT>goto</TT>
(and accepted as alternatives by most of those who shun <TT>goto</TT>)
because they are clean and structured and
pretty much
restricted to a common, idiomatic usages.
A hypothetical multi-level <TT>break</TT>, on the other hand,
would rapidly lose the inherent cleanliness of the single
<TT>break</TT>--programmers and readers of code
would have to carefully count nesting levels
to figure out what a given <TT>break</TT> did,
and the insertion of a new intermediately-nested loop
could, er, break things badly.
(By this analysis,
a numbered <TT>break</TT> statement can
be even more confusing and error-prone than a <TT>goto</TT>/label pair.)
</p><p>The right way to break out of several loops at once
(which C also does not have)
involves a syntax which allows the naming of loops,
so that a <TT>break</TT> statement can specify
the name of the loop to be broken out of.
</p><p>If you do have to break out of more than one loop at once
(or break out of a loop from inside a switch,
where <TT>break</TT> would merely end a <TT>case</TT> label)
yes, go ahead and use a <TT>goto</TT>.
(But when you find the need for a multi-level break,
it's often a sign that the loop should be broken out to its own function,
at which point you can achieve roughly the same effect
as that multi-level break
by using a premature return.)
<hr><hr><hr>
<a name="funkyasgnop">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/funkyasgnop.html"><!-- qtag -->Question 20.21</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
There seem to be a few missing operators, like <TT>^^</TT>, 
<TT>&amp;&amp;=</TT>, and <TT>-&gt;=</TT>.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
A logical
exclusive-or operator
(hypothetically ``<TT>^^</TT>'')
would be nice,
but it couldn't possibly have short-circuiting

behavior
analogous to <TT>&amp;&amp;</TT> and <TT>||</TT>
(see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=expr#shortcircuit">3.6</a>).
Similarly,
it's not clear how short-circuiting would apply to
hypothetical assignment operators <TT>&amp;&amp;=</TT> and <TT>||=</TT>.
(It's also not clear
how often <TT>&amp;&amp;=</TT> and <TT>||=</TT>
would actually be needed.)
</p><p>Though <TT>p&nbsp;=&nbsp;p-&gt;next</TT> is an extremely common 
idiom for traversing a linked list,
<TT>-&gt;</TT> is not a binary arithmetic operator.
A
hypothetical
<TT>-&gt;=</TT> operator
therefore wouldn't really fit the pattern
of the other assignment operators.
</p><p>You can write an exclusive-or macro in several ways:
<pre>
	#define XOR(a, b) ((a) &amp;&amp; !(b) || !(a) &amp;&amp; (b))	/* 1 */
	#define XOR(a, b) (!!(a) ^ !!(b))		/* 2 */
	#define XOR(a, b) (!!(a) != !!(b))		/* 3 */
	#define XOR(a, b) (!(a) ^ !(b))			/* 4 */
	#define XOR(a, b) (!(a) != !(b))		/* 5 */
	#define XOR(a, b) ((a) ? !(b) : !!(b))		/* 6 */
</pre>

The first is straight from the definition,
but is poor because it may evaluate its arguments multiple times
(see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=cpp#safemacros">10.1</a>).
The second and third
``normalize''
their operands
<a href="norml.html" rel=subdocument>[footnote]</a>
to strict 0/1 by negating them twice--the
second then applies bitwise exclusive or
(to the single remaining bit);
the third one implements exclusive-or as <TT>!=</TT>.
The fourth and fifth are based on an elementary
identity in Boolean algebra,
namely that
<blockquote>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_&nbsp;&nbsp;&nbsp;_
<br>a&nbsp;(+)&nbsp;b&nbsp;=&nbsp;a&nbsp;(+)&nbsp;b
</blockquote>(where (+) is exclusive-or
and an overbar indicates negation).
Finally,
the sixth one,
suggested by Lawrence Kirby
and Dan Pop,
uses the <TT>?:</TT> operator
to guarantee a sequence point between the two operands,
as for <TT>&amp;&amp;</TT> and <TT>||</TT>.
(There is still no ``short circuiting'' behavior,
though,
nor can there be.)
</p><p>Additional links:
A




<a href="xor.dmr.html">definitive answer</a>
from Dennis Ritchie about <TT>^^</TT>
<hr><hr><hr>
<a name="circshift">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/circshift.html"><!-- qtag -->Question 20.21a</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Does C have circular shift operators?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
No.
(Part of the reason why is that the sizes of C's types aren't
precisely defined--see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#exactsizes">1.2</a>--but
a circular shift makes most sense when applied to a word of a
particular known size.)
</p><p>You can implement a circular shift
using two regular shifts and a bitwise OR:
<pre>
	(x &lt;&lt; 13) | (x &gt;&gt; 3)	/* circular shift left 13 in 16 bits */
</pre>
<hr><hr><hr>
<a name="quintplus">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/quintplus.html"><!-- qtag -->Question 20.21b</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Is C a great language, or what?
Where else could you write something like
<TT>a+++++b</TT>
?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Well, you can't
meaningfully
write it in C, either.
The rule for lexical analysis
is that
at each point during a straightforward left-to-right scan,
the longest possible token is determined,
without regard to whether the
resulting sequence of tokens makes sense.
The fragment in the question is therefore
interpreted as
<pre>
a ++ ++ + b</pre>

and
cannot be parsed as a valid expression.
</p>



<p>References:

K&amp;R1 Sec. A2 p. 179
<br>
K&amp;R2 Sec. A2.1 p. 192
<br>
ISO Sec. 6.1
<br>
H&amp;S Sec. 2.3 pp. 19-20
<hr><hr><hr>
<a name="colonequal">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/colonequal.html"><!-- qtag -->Question 20.22</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
If the assignment operator were <TT>:=</TT>,
wouldn't it then be harder to accidentally write things like
<TT>if(a&nbsp;=&nbsp;b)</TT> ?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Yes, but it would also be
just a
little bit
more cumbersome

to type all of the assignment statements
which a typical program contains.
</p><p>In any case,
it's really too late to be worrying about this sort of thing now.
The choices of <TT>=</TT> for assignment and <TT>==</TT> for comparison
were made,
rightly or wrongly,
over two decades ago,
and are not likely to be changed.
(With respect to the question,
many compilers and versions of <TT>lint</TT>
will warn about <TT>if(a&nbsp;=&nbsp;b)</TT>
and similar expressions;
see also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=style#revtest">17.4</a>.)
</p><p>As a point of historical interest,
the choices were made based on the observation that assignment
is more frequent than comparison,
and so deserves fewer keystrokes.
In fact,
using <TT>=</TT> for assignment in



C and its predecessor B
represented a change from
B's own predecessor
BCPL,
which did use <TT>:=</TT>
as its assignment operator.

(See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#nameofc">20.38</a>).
<hr><hr><hr>
<a name="with">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/with.html"><!-- qtag -->Question 20.23</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Does C have an equivalent to Pascal's
<TT>with</TT> statement?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
No.
The way
in C
to get quick and easy access to the fields of a structure
is to declare a little local structure pointer variable
(which,
it must be admitted,
is not quite as notationally convenient
as a <TT>with</TT> statement
and doesn't save quite as many
keystrokes,
though it is probably safer).
That is,
if you have something unwieldy like
<pre>
	structarray[complex_expression].a =
		structarray[complex_expression].b +
			structarray[complex_expression].c;
</pre>
you can replace it with
<pre>
	struct whatever *p = &amp;structarray[complex_expression];
	p-&gt;a = p-&gt;b + p-&gt;c;
</pre>
<hr><hr><hr>
<a name="nestfcns">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/nestfcns.html"><!-- qtag -->Question 20.24</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Why doesn't C have nested functions?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
It's not trivial to implement nested functions
such that they have the proper access to local variables
in the containing function(s),
so
they
were deliberately left out of C as a simplification.



(<TT>gcc</TT> does allow them, as an extension.)
For many potential uses of nested functions
(e.g. <TT>qsort</TT>
comparison
functions),
an adequate if slightly
cumbersome
solution
is to use an adjacent

function with <TT>static</TT> declaration,
communicating if necessary
via a few <TT>static</TT>
variables.

(A
cleaner solution,
though unsupported by <TT>qsort</TT>,
is to pass around
a pointer to
a structure containing the necessary context.)

<hr><hr><hr>
<a name="assert">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/assert.html"><!-- qtag -->Question 20.24b</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What is <TT>assert()</TT>
and when would I use it?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
It is a macro,
defined in <TT>&lt;assert.h&gt;</TT>,
for testing ``assertions''.
An assertion essentially 
documents an assumption
being made by the programmer,
an assumption which, if violated,
would indicate a serious programming error.
For example, a function which was supposed to be called
with a non-null pointer could write
<pre>
	assert(p != NULL);
</pre>
A failed assertion terminates the program.
Assertions should <em>not</em> be used to catch expected errors,
such as <TT>malloc</TT> or <TT>fopen</TT> failures.
</p>


<p>References:

K&amp;R2 Sec. B6 pp. 253-4
<br>
ISO Sec. 7.2
<br>
H&amp;S Sec. 19.1 p. 406
<hr><hr><hr>
<a name="mixlang">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/mixlang.html"><!-- qtag -->Question 20.25</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I call FORTRAN
(C++, BASIC, Pascal,
Ada, LISP) functions from C?
(And vice versa?)
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
The answer is entirely dependent

on the machine and the specific
calling sequences of the various compilers in
use, and may not be possible at all.
Read your compiler documentation very carefully;
sometimes there is a
``mixed-language programming guide,''
although the techniques for passing arguments
and ensuring correct run-time startup
are often arcane.
Besides arranging calling sequences correctly,
you may also have to conspire between the various languages
to get aggregate data structures declared compatibly.
</p><p>For FORTRAN,


more information may be found in


FORT.gz
by Glenn Geers,
available via anonymous ftp from suphys.physics.su.oz.au in
the src directory.



Burkhard Burow's header file
<TT>cfortran.h</TT>
simplifies C/FORTRAN interfacing on
many popular machines.
It is available via anonymous ftp from zebra.desy.de




or at
<a href="http://www-zeus.desy.de/~burow"><TT>http://www-zeus.desy.de/~burow</TT></a>.
</p><p>In C++, a <TT>"C"</TT> modifier
in an external function declaration
indicates that the function
is to be called
using C calling conventions.
</p><p>In Ada, 
you can use
the
<TT>Export</TT>
and
<TT>Convention</TT>
pragmas,
and
types from the package <TT>Interfaces.C</TT>,
to arrange for C-compatible calls, parameters, and data structures.
</p>
<p>References:

H&amp;S Sec. 4.9.8 pp. 106-7
<hr><hr><hr>
<a name="langtran">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/langtran.html"><!-- qtag -->Question 20.26</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Does anyone know of a program
for converting
Pascal or FORTRAN
(or
LISP,
Ada,
awk,
``Old'' C,
...)
to C?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Several freely distributable programs are
available:
<UL><li>p2c
A Pascal to C converter
written by Dave Gillespie,
posted to comp.sources.unix in
March, 1990 (Volume 21);
also available by anonymous ftp from
<a href="ftp://csvax.cs.caltech.edu"><TT>csvax.cs.caltech.edu</TT></a>,
file
<a href="ftp://csvax.cs.caltech.edu/pub/p2c-1.20.tar.Z"><TT>pub/p2c-1.20.tar.Z</TT></a>&nbsp;.

<li>ptoc
Another
Pascal to C converter,
this one written in Pascal
(comp.sources.unix, Volume 10, also patches in Volume 13?).
<li>f2c
A FORTRAN to C converter
jointly developed by people from Bell Labs, Bellcore, and Carnegie Mellon.
(f2c is really a FORTRAN compiler with a C backend--the
output is not intended to be maintainable.)
To find out more about f2c, send the mail message
``send index from f2c''
to netlib@research.att.com or research!netlib.
(It is also available via anonymous ftp on
<a href="ftp://netlib.att.com"><TT>netlib.att.com</TT></a>,
in directory
<a href="ftp://netlib.att.com/netlib/f2c/"><TT>netlib/f2c/</TT></a>.)

</UL><UL><li>A PL/M to C converter was posted to alt.sources in April, 1991.
</UL></p><p>The following companies sell various translation tools and services:
</p><UL><li><pre>

Cobalt Blue
2940 Union Ave., Suite C
San Jose, CA  95124  USA
(+1) 408 723 0474
</pre>
<li><pre>

Promula Development Corp.
3620 N. High St., Suite 301
Columbus, OH  43214  USA
(+1) 614 263 5454
</pre>
<li><pre>

Micro-Processor Services Inc.
92 Stone Hurst Lane
Dix Hills, NY  11746  USA
(+1) 516 499 4461
</pre>
</UL><p>See also questions
<a href="/~scs/cgi-bin/faqcat.cgi?sec=ansi#cproto">11.31</a>
and
<a href="/~scs/cgi-bin/faqcat.cgi?sec=resources#sources">18.16</a>.
<hr><hr><hr>
<a name="cplusplus">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/cplusplus.html"><!-- qtag -->Question 20.27</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Is C++ a superset of C?
What are the differences between C and C++?
Can I use a C++ compiler to compile C code?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
C++ was derived from C,
and is largely based on it,
but there are some legal C constructs
which are not legal C++.
Conversely,
ANSI C inherited several features from C++,
including prototypes and <TT>const</TT>,
so neither language is really a subset or superset of the other;
the two also define the meaning of some common constructs differently.

</p><p>The most important feature of C++ not found in C is of course 
the extended structure
known as a <TT>class</TT>

which
along with operator overloading
makes object-oriented programming convenient.
There are
several
other differences and new features:
variables may be declared anywhere in a block;
<TT>const</TT> variables
may be true compile-time
constants;
structure tags are implicitly typedeffed;

an <TT>&amp;</TT> in a parameter declaration requests pass by reference;
and
the <TT>new</TT> and <TT>delete</TT> operators,
along with per-object constructors and destructors,
simplify dynamic data structure management.
There are
a host of
mechanisms tied up with 
classes and object-oriented programming:
inheritance,
<TT>friend</TT>s,
virtual functions,
templates,
etc.
(This list of C++ features is not intended to be complete;
C++ programmers will notice many omissions.)
</p><p>Some
features of C which keep it from being a strict subset of C++
(that is, which keep C programs from necessarily being 
acceptable to C++ compilers)
are that
<TT>main</TT>
may be called recursively,
character constants are of type <TT>int</TT>,
prototypes are not required,
and
<TT>void&nbsp;*</TT>
implicitly converts to other pointer types.

Also, every keyword in C++ which is not a keyword in C
is available in C as an identifier;
C programs which use words like <TT>class</TT> and <TT>friend</TT>
as ordinary identifiers will be rejected by C++ compilers.
</p><p>In spite of the differences,
many
C programs will
compile correctly in a C++ environment,
and many recent compilers
offer both C and C++ compilation modes.
(But it's usually a bad idea to compile straight C code as if it were C++;
the languages are different enough
that you'll generally get poor results.)
</p><p>See also
questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=charstring#sizeofchar">8.9</a> and <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#nestcomment">20.20</a>.

</p><p>Additional links:
<br>
<br>

<a href="http://www.research.att.com/~bs/bs_faq.html#C-is-subset">Bjarne Stroustrup's answer</a>
on the subset/superset question
<br>
<br>
an




<a href="cplusplus.rs.html">article by Richard Stamp</a>
listing some differences
<br>
<br>
an




<a href="cplusplus.nr.html">article by ``Noone Really''</a>
listing some more
</p>



<p>References:

H&amp;S p. xviii, Sec. 1.1.5 p. 6, Sec. 2.8 pp. 36-7, Sec. 4.9 pp. 104-107
<hr><hr><hr>
<a name="soundex">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/soundex.html"><!-- qtag -->Question 20.28</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
I need
a sort of an ``approximate'' strcmp routine, for comparing
two strings for close, but not necessarily exact, equality.
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Some nice information and algorithms having to do with 
approximate string matching,
as well as a useful
bibliography,
can be found in Sun Wu and
Udi Manber's paper
``AGREP--A Fast Approximate Pattern-Matching Tool.''
</p><p>Another
approach
involves
the ``soundex''
algorithm,
which
maps similar-sounding words to the same codes.
Soundex
was designed for discovering similar-sounding names
(for telephone directory assistance, as it happens),
but
it
can be pressed into service for processing arbitrary words.
</p>
<p>References:

Knuth Sec. 6 pp. 391-2 Volume 3
<br>
Wu and Manber,
``AGREP--A Fast Approximate Pattern-Matching Tool''

<hr><hr><hr>
<a name="hash">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/hash.html"><!-- qtag -->Question 20.29</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What is hashing?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Hashing is the process of
mapping
strings
to integers,
usually in a relatively small range.
A ``hash function'' maps a string
(or
some
other data structure)
to



a bounded number
(the ``hash bucket'')
which
can more easily
be
used
as an index in an array,
or for performing repeated comparisons.

(Obviously,
a mapping from a potentially huge set of strings
to a small set of integers
will not be unique.
Any
algorithm using hashing
therefore has to deal with the possibility of 
``collisions.'')

</p><p>Many hashing functions
and related algorithms
have been developed;
a full treatment is beyond the scope of this list.
An extremely simple
hash function
for strings
is simply to add up the values of all the characters:
<pre>
unsigned hash(char *str)
{
	unsigned int h = 0;
	while(*str != '\0')
		h += *str++;
	return h % NBUCKETS;
}
</pre>
A somewhat better hash function is
<pre>
unsigned hash(char *str)
{
	unsigned int h = 0;
	while(*str != '\0')
		h = (256 * h + *str++) % NBUCKETS;
	return h;
}
</pre>

which actually treats the input string as a large binary number
(<TT>8 * strlen(str)</TT> bits long,
assuming characters are 8 bits)
and computes that number modulo NBUCKETS,
by Horner's rule.
(Here it is important that NBUCKETS be prime,
among other things.
To remove the assumption that characters are 8 bits,
use <TT>UCHAR_MAX+1</TT> instead of 256;
the ``large binary number'' will then be
<TT>CHAR_BIT * strlen(str)</TT> bits long.
<TT>UCHAR_MAX</TT> and <TT>CHAR_BIT</TT> are defined in <TT>&lt;limits.h&gt;</TT>.)
</p><p>When
the set of strings is known in advance,
it is also possible to devise ``perfect''
hashing functions which
guarantee a collisionless, dense mapping.
</p>


<p>References:

K&amp;R2 Sec. 6.6
<br>
Knuth Sec. 6.4 pp. 506-549 Volume 3
<br>
Sedgewick Sec. 16 pp. 231-244
<hr><hr><hr>
<a name="gaussian">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/gaussian.html"><!-- qtag -->Question 20.30</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I generate random numbers with a
normal or
Gaussian distribution?
</p>
<p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
See question <a href="/~scs/cgi-bin/faqcat.cgi?sec=lib#gaussian">13.20</a>.
<hr><hr><hr>
<a name="zeller">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/zeller.html"><!-- qtag -->Question 20.31</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
How can I find the day of the week given the date?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
Here are three methods:
<OL><li>Use
<TT>mktime</TT>
or <TT>localtime</TT>
(see question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=lib#mktime">13.13</a>).
Here is

a code fragment which computes the day of the week for
February 29, 2000:
<pre>
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

char *wday[] = {"Sunday", "Monday", "Tuesday", "Wednesday",
		"Thursday", "Friday", "Saturday"};

struct tm tm;

tm.tm_mon = 2 - 1;
tm.tm_mday = 29;
tm.tm_year = 2000 - 1900;
tm.tm_hour = tm.tm_min = tm.tm_sec = 0;
tm.tm_isdst = -1;

if(mktime(&amp;tm) != -1)
	printf("%s\n", wday[tm.tm_wday]);
</pre>
When using <TT>mktime</TT> like this,
it's usually important to set <TT>tm_isdst</TT> to -1,
as shown
(especially if <TT>tm_hour</TT> is 0),
otherwise a daylight saving time
correction could push the time past midnight into another day.

<li>Use
Zeller's congruence,
which says that if
<br>
<br>
<pre>
	<I>J</I> is the number of the century [i.e. the year <TT>/</TT> 100],
	<I>K</I> the year within the century [i.e. the year <TT>%</TT> 100],
	<I>m</I> the month,
	<I>q</I> the day of the month,
	<I>h</I> the day of the week [where 1 is Sunday];
</pre>
<br>
<br>
and if January and February are taken as months 13 and 14 of 
the previous year
[affecting both <I>J</I> and <I>K</I>];
then <I>h</I>
for the Gregorian calendar
is the remainder when the sum
<br>
<br>
<pre>
	<I>q</I> + 26(<I>m</I> + 1) / 10 + <I>K</I> + <I>K</I>/4 + <I>J</I>/4 - 2<I>J</I>
</pre>
<br>
<br>
is divided by 7,
and where all intermediate remainders are discarded.
<a href="zeller2.html" rel=subdocument>[footnote]</a>
The translation into C is straightforward:
<pre>
	h = (q + 26 * (m + 1) / 10 + K + K/4 + J/4 + 5*J) % 7;
</pre>
(where
we use <TT>+5*J</TT> instead of <TT>-2*J</TT>
to make sure that
both operands of the modulus operator <TT>%</TT> are
positive;
this bias totalling <TT>7*J</TT>
will obviously not change the final value of <TT>h</TT>, modulo 7).
<li>Use
this elegant code
by
Tomohiko Sakamoto:


<pre>
int dayofweek(int y, int m, int d)	/* 0 = Sunday */
{
	static int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};
	y -= m &lt; 3;
	return (y + y/4 - y/100 + y/400 + t[m-1] + d) % 7;
}
</pre>
</OL></p><p>See also questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=lib#calendar">13.14</a>
and <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#leapyear">20.32</a>.
</p>
<p>References:

ISO Sec. 7.12.2.3
<br>
Chr. Zeller, ``Kalender-Formeln''

<hr><hr><hr>
<a name="leapyear">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/leapyear.html"><!-- qtag -->Question 20.32</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Is <TT>(year&nbsp;%&nbsp;4&nbsp;==&nbsp;0)</TT> an accurate test for leap years?
(Was 2000 a leap year?)
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
No, it's not accurate
(and yes, 2000 was a leap year).
The
actual rules
for the
present
Gregorian calendar
are that leap years occur every four years,
but not every 100 years,
<em>except</em>
that they do occur every 400 years, after all.
In C,
these rules can be expressed as:
<pre>
	year % 4 == 0 &amp;&amp; (year % 100 != 0 || year % 400 == 0)
</pre>
See a good
astronomical almanac or other reference
<a href="refs.html" rel=subdocument>[footnote]</a>
for details.


</p><p>Actually,
if the
domain of interest is limited
(perhaps by the
range of a signed 32-bit <TT>time_t</TT>)
such that
the only century year it encompasses is 2000,
the expression
<pre>
	year&nbsp;%&nbsp;4&nbsp;==&nbsp;0		/* 1901-2099 only */
</pre>
is accurate,
if less than robust.
</p><p>If you trust the implementor of the C library,
you can use <TT>mktime</TT> to determine whether a given year 
is a leap year;
see the code fragments
in questions <a href="/~scs/cgi-bin/faqcat.cgi?sec=lib#calendar">13.14</a> or <a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#zeller">20.31</a>
for hints.
</p><p>Note also that the transition from the
Julian to the
Gregorian calendar involved
deleting several days
to make up for accumulated errors.
(The transition was first made
in Catholic countries under Pope Gregory XIII
in October, 1582,
and involved deleting 10 days.
In the British Empire,
eleven

days were deleted
when the Gregorian calendar was adopted
in September 1752.
A few countries didn't switch until the
20th
century.)
Calendar code which has to work for
historical dates
must
therefore
be especially careful.
</p><p>See also question <a href="/~scs/cgi-bin/faqcat.cgi?sec=lib#y2k">13.14b</a>.
<hr><hr><hr>
<a name="leapsec">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/leapsec.html"><!-- qtag -->Question 20.33</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Why can <TT>tm_sec</TT>
in the <TT>tm</TT> structure
range from 0 to 61,
suggesting that there can be 62 seconds in a minute?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
That's actually a buglet
in the Standard.
There can be 61 seconds in a minute
during
a leap second.
It's possible for there to be two leap seconds in a year,
but it turns out
that it's guaranteed that they'll never both 
occur in the same day
(let alone the same minute).
<hr><hr><hr>
<a name="quine">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/quine.html"><!-- qtag -->Question 20.34</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Here's a good puzzle:
how
do you write a program which produces its own source code as
output?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
It is actually quite difficult to write
a self-reproducing program
that is truly portable,
due particularly to
quoting and
character set difficulties.
</p><p>Here is a classic example
(which
ought to be
presented on one line,
although it will fix itself
the first time it's run):
<pre>
char*s="char*s=%c%s%c;main(){printf(s,34,s,34);}";
main(){printf(s,34,s,34);}
</pre>
(This program
has a few deficiencies,
among other things
neglecting to
<TT>#include</TT> <TT>&lt;stdio.h&gt;</TT>,
and
assuming
that the double-quote character <TT>"</TT> has the value 34,
as it does in ASCII.)
</p><p>Here is an improved version, posted by James Hu:
<pre>
#define q(k)main(){return!puts(#k"\nq("#k")");}
q(#define q(k)main(){return!puts(#k"\nq("#k")");})
</pre>
<hr><hr><hr>
<a name="duff">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/duff.html"><!-- qtag -->Question 20.35</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What is ``Duff's Device''?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>

It's
a devastatingly
devious way of
unrolling a loop,
devised by Tom Duff while he was at Lucasfilm.
In its ``classic''
form,
it was used to copy bytes,
and
looked
like this:
<pre>
	register n = (count + 7) / 8;	/* count &gt; 0 assumed */
	switch (count % 8)
	{
	case 0:	   do { *to = *from++;
	case 7:		*to = *from++;
	case 6:		*to = *from++;
	case 5:		*to = *from++;
	case 4:		*to = *from++;
	case 3:		*to = *from++;
	case 2:		*to = *from++;
	case 1:		*to = *from++;
		      } while (--n &gt; 0);
	}
</pre>

where <TT>count</TT> bytes
are to be copied
from the array pointed to by <TT>from</TT>
to the memory location pointed to by <TT>to</TT>
(which is a memory-mapped device output register,
which is why <TT>to</TT> isn't incremented).
It solves the problem of handling the leftover bytes
(when <TT>count</TT> isn't a multiple of 8)
by interleaving a
<TT>switch</TT> statement
with the loop
which copies bytes 8 at a time.
(Believe it or not, it <em>is</em>
legal
to have <TT>case</TT> labels buried
within blocks
nested in a <TT>switch</TT> statement
like this.
In his announcement of the technique to C's developers and the world,
Duff noted that C's <TT>switch</TT> syntax,
in particular its
``fall through''
behavior,
had long been controversial,
and that
``This code forms some sort of argument in that debate,
but I'm not sure whether it's for or against.'')
</p><p>Additional links:


<a href="/~scs/cgi-bin/faqcat.cgi?sec=misc#duffexpln">longer explanation</a>
<hr><hr><hr>
<a name="ioccc">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/ioccc.html"><!-- qtag -->Question 20.36</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
When will the next
International
Obfuscated C Code Contest
(IOCCC)
be held?
How do I submit contest entries?
Who won this year's IOCCC?
How can I get a copy of
the
current and
previous
winning entries?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
The contest
schedule varies over time;
see
<a href="http://www.ioccc.org/index.html"><TT>http://www.ioccc.org/index.html</TT></a>
for current details.
</p><p>Contest winners
are usually announced at
a Usenix conference,
and are
posted to the net sometime
thereafter.
Winning entries from previous years
(back to 1984)
are archived at
<a href="ftp://ftp.uu.net"><TT>ftp.uu.net</TT></a>
(see question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=resources#sources">18.16</a>)
under the directory <a href="ftp://ftp.uu.net/pub/ioccc/"><TT>pub/ioccc/</TT></a>;

see also
<a href="http://www.ioccc.org/index.html"><TT>http://www.ioccc.org/index.html</TT></a>
.
</p>
<p>References:

Don Libes, <I>Obfuscated C and Other Mysteries</I>
<hr><hr><hr>
<a name="entry">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/entry.html"><!-- qtag -->Question 20.37</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What was the <TT>entry</TT> keyword
mentioned in K&amp;R1?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
It was reserved to allow
the possibility
of having
functions with multiple,
differently-named entry points,
&agrave; la FORTRAN.
It was not,
to anyone's knowledge,
ever implemented
(nor does anyone remember
what sort of syntax might have been imagined for it).

It
has been
withdrawn,
and is not a keyword in ANSI C.
(See also question
<a href="/~scs/cgi-bin/faqcat.cgi?sec=decl#auto">1.12</a>.)
</p>
<p>References:

K&amp;R2 p. 259 Appendix C
<hr><hr><hr>
<a name="nameofc">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/nameofc.html"><!-- qtag -->Question 20.38</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Where does the name ``C'' come from, anyway?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
C

was derived from
Ken Thompson's experimental language
B,
which was inspired by
Martin Richards's
BCPL
(Basic Combined Programming Language),
which was a simplification of CPL
(Combined Programming Language,
or perhaps
Cambridge Programming Language).
For a while,
there was speculation that C's successor might be named P
(the third letter in BCPL) instead of D,
but of course the most visible descendant language today is
C++.
</p><p>References:

Dennis Ritchie,
``The Development of the C Language''

<hr><hr><hr>
<a name="pronounce">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/pronounce.html"><!-- qtag -->Question 20.39</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>

How do you pronounce ``<TT>char</TT>''?
What's that funny name for the ``<TT>#</TT>'' character?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
You can pronounce the C keyword ``<TT>char</TT>''
in at least three ways:
like
the English words ``char,'' ``care,'' or
``car''
(or maybe even ``character'');
the choice is arbitrary.

Bell Labs once proposed the (now obsolete) term
``octothorpe'' for the ``#'' character.
</p><p>Trivia questions like these aren't any more pertinent for

comp.lang.c than they are for most of the other groups they
frequently come up in.

You can find lots of information
in the net.announce.newusers frequently-asked questions postings,
the ``jargon file'' (also published as
<I>The [New] Hacker's Dictionary</I>),
and
the old Usenet
ASCII pronunciation list.
(The pronunciation list also appears in the jargon file under
ASCII, as well as in the comp.unix
frequently-asked questions list.)
<hr><hr><hr>
<a name="lvalue">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/lvalue.html"><!-- qtag -->Question 20.39b</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
What do ``lvalue'' and ``rvalue'' mean?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>

Simply speaking,
an <a href="../sx1/index.html#lvalue"><dfn>lvalue</dfn></a> is an expression that could appear
on the <B>l</B>eft-hand sign of an assignment;
you can also think of it as denoting
an object that has a <B>l</B>ocation.
(But see question <a href="/~scs/cgi-bin/faqcat.cgi?sec=aryptr#arraylval">6.7</a> concerning arrays.)
An
<a href="../sx1/index.html#rvalue"><dfn>rvalue</dfn></a> is any expression that has a value
(and that can therefore appear
on the <B>r</B>ight-hand sign of an assignment).
<hr><hr><hr>
<a name="faqavail">
<h1>
comp.lang.c FAQ list
<font color=blue>&middot;</font>
<a href="../misc/faqavail.html"><!-- qtag -->Question 20.40</a>
</h1>
<p>
<font face=Helvetica size=8 color=blue><b>Q:</b></font>
Where can I get extra copies of this list?
</p><p><hr>
<p>
<font face=Helvetica size=8 color=blue><b>A:</b></font>
An up-to-date copy
may be obtained from
<a href="ftp://ftp.eskimo.com"><TT>ftp.eskimo.com</TT></a>
in directory
<a href="ftp://ftp.eskimo.com/home/scs/C-faq"><TT>home/scs/C-faq/</TT></a>.
You can also
just pull it off the net;
it
is normally posted
to comp.lang.c
on the first of each month,
with an Expires: line which should keep it around all month.
A parallel,
abridged version is
available
(and posted),



as is a list of changes
accompanying each significantly updated version.
</p><p>The various versions of
this
list
are
also
posted to
the newsgroups
comp.answers and news.answers.
Several sites
archive news.answers postings and other FAQ lists,
including
this one;

two sites are
<a href="ftp://rtfm.mit.edu"><TT>rtfm.mit.edu</TT></a>
(directories
<a href="ftp://rtfm.mit.edu/pub/usenet/news.answers/C-faq/"><TT>pub/usenet/news.answers/C-faq/</TT></a>
and
<a href="ftp://rtfm.mit.edu/pub/usenet/comp.lang.c/"><TT>pub/usenet/comp.lang.c/</TT></a>)
and
<a href="ftp://ftp.uu.net"><TT>ftp.uu.net</TT></a>
(directory
<a href="ftp://ftp.uu.net/usenet/news.answers/C-faq/"><TT>usenet/news.answers/C-faq/</TT></a>).
If you don't have ftp access,
a mailserver at rtfm.mit.edu can mail you FAQ lists:
send a message containing the single word
``<TT>help</TT>''
to
<a href="mailto:mail-server@rtfm.mit.edu"><TT>mail-server@rtfm.mit.edu</TT></a>
for more information.
See the meta-FAQ list in news.answers for more information.
</p><p>An extended version
of this FAQ list
has been
published by 
Addison-Wesley as
<I>C Programming FAQs: Frequently Asked Questions</I>
(ISBN 0-201-84519-9).
An errata list is at
<a href="http://www.eskimo.com/~scs/C-faq/book/Errata.html"><TT>http://www.eskimo.com/~scs/C-faq/book/Errata.html</TT></a>
and on
<a href="ftp://ftp.eskimo.com"><TT>ftp.eskimo.com</TT></a>
in
<a href="ftp://ftp.eskimo.com/home/scs/ftp/C-faq/book/Errata"><TT>home/scs/ftp/C-faq/book/Errata</TT></a>
.
<hr><hr><hr>
<hr>
<p>
Read sequentially:
<a href="/~scs/cgi-bin/faqcat.cgi?sec=osdep" rev=precedes>prev</a>
<a href="/~scs/cgi-bin/faqcat.cgi?sec=" rel=precedes>next</a>
<a href="/~scs/cgi-bin/faqcat.cgi" rev=subdocument>up</a>
</p>
<hr>
<p>
<br><!-- lastfooter -->
<a href="../about.html">about this FAQ list</a>
&nbsp;
<a href="../eskimo.html">about eskimo</a>
&nbsp;
<a href="../search.html">search</a>
&nbsp;
<a href="../feedback.html">feedback</a>
&nbsp;
<a href="copyright.html">copyright</a>
<p>
Hosted by
<a href="http://www.eskimo.com/"><img src="http://www.eskimo.com/img/link/eskitiny.gif" alt="Eskimo North"></a>
</body>
</html>
